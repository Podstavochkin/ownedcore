<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>OwnedCore - Архив сигналов</title>
    <!-- Библиотека для графиков -->
    <script src="https://unpkg.com/lightweight-charts@4.1.3/dist/lightweight-charts.standalone.production.js" 
            onerror="console.warn('Failed to load lightweight-charts from unpkg, trying jsdelivr...'); 
                     this.src='https://cdn.jsdelivr.net/npm/lightweight-charts@4.1.3/dist/lightweight-charts.standalone.production.js';"></script>
    <style>
        :root {
            /* Основная цветовая схема - Dark Cyberpunk */
            --bg-primary: #000000;
            --bg-secondary: #0a0a0a;
            --bg-tertiary: #111111;
            --bg-card: rgba(0, 255, 65, 0.05);
            --bg-modal: rgba(0, 0, 0, 0.98);
            
            /* Текст */
            --text-primary: #00ff41;
            --text-secondary: #00cc33;
            --text-muted: #008822;
            
            /* Акцентные цвета - Cyberpunk Neon */
            --accent-primary: #00ff41;
            --accent-secondary: #ff006e;
            --accent-success: #00ff41;
            --accent-danger: #ff006e;
            --accent-warning: #ffaa00;
            --accent-info: #00d9ff;
            
            /* Градиенты - Cyberpunk */
            --gradient-primary: linear-gradient(135deg, #00ff41 0%, #00cc33 50%, #ff006e 100%);
            --gradient-success: linear-gradient(135deg, #00ff41 0%, #00cc33 100%);
            --gradient-danger: linear-gradient(135deg, #ff006e 0%, #cc0055 100%);
            --gradient-warning: linear-gradient(135deg, #ffaa00 0%, #ff8800 100%);
            
            /* Cyberpunk эффекты */
            --glass-bg: rgba(0, 255, 65, 0.08);
            --glass-border: rgba(0, 255, 65, 0.3);
            --neon-glow: 0 0 10px rgba(0, 255, 65, 0.5), 0 0 20px rgba(0, 255, 65, 0.3), 0 0 30px rgba(0, 255, 65, 0.2);
            --neon-glow-pink: 0 0 10px rgba(255, 0, 110, 0.5), 0 0 20px rgba(255, 0, 110, 0.3), 0 0 30px rgba(255, 0, 110, 0.2);
            
            /* Тени */
            --shadow-sm: 0 1px 3px rgba(0, 0, 0, 0.12), 0 1px 2px rgba(0, 0, 0, 0.24);
            --shadow-md: 0 4px 6px rgba(0, 0, 0, 0.1), 0 1px 3px rgba(0, 0, 0, 0.08);
            --shadow-lg: 0 10px 15px rgba(0, 0, 0, 0.1), 0 4px 6px rgba(0, 0, 0, 0.05);
            --shadow-xl: 0 20px 25px rgba(0, 0, 0, 0.1), 0 10px 10px rgba(0, 0, 0, 0.04);
            
            /* Анимации */
            --transition-fast: 0.15s ease-in-out;
            --transition-normal: 0.3s ease-in-out;
            --transition-slow: 0.5s ease-in-out;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', 'Monaco', 'Consolas', monospace;
            background: var(--bg-primary);
            color: var(--text-primary);
            line-height: 1.6;
            overflow-x: hidden;
            position: relative;
        }

        /* Сканирующая линия */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 2px;
            background: linear-gradient(90deg, transparent, #00ff41, transparent);
            animation: scanLine 3s linear infinite;
            z-index: 10000;
            pointer-events: none;
        }

        @keyframes scanLine {
            0% { transform: translateY(0); opacity: 1; }
            100% { transform: translateY(100vh); opacity: 0; }
        }

        /* Цифровой шум на фоне */
        body::after {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-image: 
                repeating-linear-gradient(0deg, transparent, transparent 2px, rgba(0, 255, 65, 0.03) 2px, rgba(0, 255, 65, 0.03) 4px),
                repeating-linear-gradient(90deg, transparent, transparent 2px, rgba(0, 255, 65, 0.03) 2px, rgba(0, 255, 65, 0.03) 4px);
            pointer-events: none;
            z-index: 0;
        }

        /* Заголовок - Cyberpunk Style */
        .header {
            background: rgba(0, 0, 0, 0.9);
            border-bottom: 2px solid var(--accent-primary);
            padding: 1.5rem 2rem;
            box-shadow: var(--neon-glow);
            position: relative;
            overflow: visible;
        }

        .header::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg, transparent, rgba(0, 255, 65, 0.1), transparent);
            animation: glitch 4s infinite;
            z-index: 0;
        }

        @keyframes glitch {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-2px); }
            50% { transform: translateX(2px); }
            75% { transform: translateX(-1px); }
        }

        .header::after {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 2px;
            background: var(--accent-primary);
            animation: scanHeader 2s infinite;
            z-index: 1;
            box-shadow: var(--neon-glow);
        }

        @keyframes scanHeader {
            0% { left: -100%; }
            100% { left: 100%; }
        }

        .header-content {
            position: relative;
            z-index: 2;
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 2rem;
        }

        .logo-container {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .logo {
            width: 48px;
            height: 48px;
            position: relative;
            animation: logoGlow 1.5s ease-in-out infinite alternate, glitchLogo 3s infinite;
            filter: drop-shadow(var(--neon-glow));
        }

        @keyframes logoGlow {
            0% { filter: drop-shadow(0 0 5px rgba(0, 255, 65, 0.5)); }
            100% { filter: drop-shadow(0 0 20px rgba(0, 255, 65, 1)); }
        }

        @keyframes glitchLogo {
            0%, 100% { transform: translate(0); }
            20% { transform: translate(-2px, 2px); }
            40% { transform: translate(-2px, -2px); }
            60% { transform: translate(2px, 2px); }
            80% { transform: translate(2px, -2px); }
        }

        .header h1 {
            font-size: 1.75rem;
            font-weight: 700;
            color: var(--accent-primary);
            text-shadow: var(--neon-glow);
            letter-spacing: 2px;
            margin: 0;
            font-family: 'Courier New', monospace;
            text-transform: uppercase;
            animation: textGlitch 4s infinite;
        }

        @keyframes textGlitch {
            0%, 100% { text-shadow: var(--neon-glow); }
            25% { text-shadow: var(--neon-glow), 2px 0 0 rgba(255, 0, 110, 0.5); }
            50% { text-shadow: var(--neon-glow), -2px 0 0 rgba(255, 0, 110, 0.5); }
            75% { text-shadow: var(--neon-glow), 0 2px 0 rgba(255, 0, 110, 0.5); }
        }

        .header-controls {
            display: flex;
            gap: 1rem;
            align-items: center;
            position: relative;
            overflow: visible;
        }

        /* Навигационное меню */
        .nav-menu {
            display: flex;
            gap: 0.5rem;
            align-items: center;
            flex: 1;
            justify-content: center;
            position: relative;
            overflow: visible;
        }

        .nav-item {
            padding: 0.5rem 1rem;
            text-decoration: none;
            color: var(--text-primary);
            border: 1px solid transparent;
            transition: var(--transition-normal);
            font-family: 'Courier New', monospace;
            text-transform: uppercase;
            font-size: 0.875rem;
            letter-spacing: 1px;
        }

        .nav-item:hover {
            border-color: var(--accent-primary);
            box-shadow: var(--neon-glow);
            color: var(--accent-primary);
        }

        .nav-item.active {
            border-color: var(--accent-primary);
            color: var(--accent-primary);
            box-shadow: var(--neon-glow);
        }

        /* Выпадающее меню дизайна */
        .design-dropdown {
            position: relative;
            z-index: 10002;
        }

        .design-btn {
            padding: 0.5rem 1rem;
            background: transparent;
            color: var(--accent-primary);
            border: 1px solid var(--accent-primary);
            box-shadow: var(--neon-glow);
            cursor: pointer;
            font-family: 'Courier New', monospace;
            text-transform: uppercase;
            font-size: 0.875rem;
            letter-spacing: 1px;
            position: relative;
        }

        .design-btn::after {
            content: ' ▼';
            font-size: 0.7rem;
        }

        .design-menu {
            position: absolute;
            top: 100%;
            right: 0;
            margin-top: 0.5rem;
            background: rgba(0, 0, 0, 0.95);
            border: 2px solid var(--accent-primary);
            box-shadow: var(--neon-glow);
            min-width: 200px;
            display: none;
            z-index: 10001;
            overflow: visible;
        }

        /* Для космической темы используем fixed позиционирование */
        body.theme-cosmic .design-menu {
            position: fixed !important;
            margin-top: 0;
        }

        .design-menu.active {
            display: block;
        }

        .design-option {
            padding: 0.75rem 1rem;
            color: var(--text-primary);
            cursor: pointer;
            transition: var(--transition-normal);
            border-bottom: 1px solid rgba(0, 255, 65, 0.2);
            font-family: 'Courier New', monospace;
            text-transform: uppercase;
            font-size: 0.8rem;
        }

        .design-option:last-child {
            border-bottom: none;
        }

        .design-option:hover {
            background: rgba(0, 255, 65, 0.1);
            color: var(--accent-primary);
        }

        .design-option.active {
            background: rgba(0, 255, 65, 0.2);
            color: var(--accent-primary);
            box-shadow: inset 0 0 10px rgba(0, 255, 65, 0.3);
        }

        /* Кнопки */
        .btn {
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: 0.5rem;
            font-weight: 600;
            cursor: pointer;
            transition: var(--transition-normal);
            text-decoration: none;
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.875rem;
        }

        .btn-primary {
            background: transparent;
            color: var(--accent-primary);
            border: 2px solid var(--accent-primary);
            box-shadow: var(--neon-glow);
            position: relative;
            overflow: hidden;
            font-family: 'Courier New', monospace;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .btn-primary::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: rgba(0, 255, 65, 0.2);
            transition: left 0.3s ease;
            z-index: -1;
        }

        .btn-primary:hover::before {
            left: 0;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: var(--neon-glow), 0 0 30px rgba(0, 255, 65, 0.6);
            color: #ffffff;
            text-shadow: 0 0 10px var(--accent-primary);
        }

        .btn-secondary {
            background: transparent;
            color: var(--accent-secondary);
            border: 2px solid var(--accent-secondary);
            box-shadow: var(--neon-glow-pink);
            font-family: 'Courier New', monospace;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .btn-secondary:hover {
            background: rgba(255, 0, 110, 0.1);
            box-shadow: var(--neon-glow-pink), 0 0 30px rgba(255, 0, 110, 0.6);
            transform: translateY(-2px);
            color: #ffffff;
            text-shadow: 0 0 10px var(--accent-secondary);
        }

        .live-toggle-btn {
            padding: 0.5rem 1.25rem;
            border: 2px solid var(--accent-warning);
            background: transparent;
            color: var(--accent-warning);
            text-transform: uppercase;
            letter-spacing: 1px;
            font-family: 'Courier New', monospace;
            box-shadow: 0 0 12px rgba(255, 170, 0, 0.4);
            transition: var(--transition-normal);
        }

        .live-toggle-btn.live-on {
            border-color: var(--accent-success);
            color: var(--accent-success);
            box-shadow: 0 0 15px rgba(0, 255, 65, 0.5);
        }

        .live-toggle-btn.live-off {
            border-color: var(--accent-danger);
            color: var(--accent-danger);
            box-shadow: 0 0 15px rgba(255, 0, 110, 0.5);
        }

        .live-toggle-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .trade-status {
            font-size: 0.8rem;
            line-height: 1.2;
            display: flex;
            flex-direction: column;
            gap: 0.2rem;
            max-width: 100%;
            word-break: break-word;
        }

        .trade-status-main {
            font-weight: 600;
            letter-spacing: 0.03em;
            text-transform: uppercase;
        }

        .trade-status-meta {
            display: flex;
            flex-direction: column;
            gap: 0.15rem;
            font-size: 0.7rem;
            color: var(--text-muted);
            overflow-wrap: anywhere;
            max-width: 100%;
        }

        .trade-status-meta span {
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .trade-status-success {
            color: var(--accent-success);
        }

        .trade-status-failed {
            color: var(--accent-danger);
        }

        .trade-status-disabled {
            color: var(--accent-warning);
        }

        .trade-status-warning {
            color: #f6ad55; /* Оранжевый для предупреждений */
        }

        .trade-status-info {
            color: #63b3ed; /* Голубой для информационных статусов */
        }

        /* Основной контент */
        .main-content {
            padding: 2rem;
            max-width: 1400px;
            margin: 0 auto;
        }

        /* Статистика */
        .stats-section {
            margin-bottom: 2rem;
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1.5rem;
            margin-bottom: 1.5rem;
        }
        
        .stats-grid:last-child {
            margin-bottom: 0;
        }

        .stat-card {
            background: rgba(0, 0, 0, 0.7);
            border-radius: 0;
            padding: 1.5rem;
            box-shadow: var(--neon-glow);
            border: 2px solid var(--accent-primary);
            transition: var(--transition-normal);
            position: relative;
            overflow: hidden;
        }

        .stat-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: var(--accent-primary);
            box-shadow: var(--neon-glow);
        }

        .stat-card::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 3px;
            height: 100%;
            background: var(--accent-primary);
            box-shadow: var(--neon-glow);
        }

        .stat-card:hover {
            transform: translateY(-4px);
            box-shadow: var(--neon-glow), 0 0 40px rgba(0, 255, 65, 0.4);
            border-color: var(--accent-primary);
        }

        .stat-value {
            font-size: 2rem;
            font-weight: 700;
            margin-bottom: 0.5rem;
            background: var(--gradient-primary);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .stat-label {
            color: var(--text-secondary);
            font-size: 0.875rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        /* Фильтры */
        .filters-section {
            background: rgba(0, 0, 0, 0.7);
            border-radius: 0;
            padding: 1.5rem;
            margin-bottom: 2rem;
            box-shadow: var(--neon-glow);
            border: 2px solid var(--accent-primary);
        }

        .filters-row {
            display: flex;
            gap: 1rem;
            align-items: center;
            flex-wrap: wrap;
            margin-bottom: 1rem;
        }

        .filters-row:last-child {
            margin-bottom: 0;
        }

        .search-box {
            flex: 1;
            min-width: 300px;
            position: relative;
        }

        .search-input {
            width: 100%;
            padding: 0.75rem 1rem 0.75rem 2.5rem;
            background: var(--bg-tertiary);
            border: 1px solid var(--bg-tertiary);
            border-radius: 0.5rem;
            color: var(--text-primary);
            font-size: 0.875rem;
            transition: var(--transition-normal);
        }

        .search-input:focus {
            outline: none;
            border-color: var(--accent-primary);
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .search-icon {
            position: absolute;
            left: 0.75rem;
            top: 50%;
            transform: translateY(-50%);
            color: var(--text-muted);
        }

        .filter-buttons {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
        }

        .filter-btn {
            padding: 0.5rem 1rem;
            background: var(--bg-tertiary);
            border: 1px solid var(--bg-tertiary);
            border-radius: 0.5rem;
            color: var(--text-secondary);
            cursor: pointer;
            transition: var(--transition-normal);
            font-size: 0.875rem;
        }

        .filter-btn.active {
            background: var(--accent-primary);
            color: white;
            border-color: var(--accent-primary);
        }

        /* Таблица сигналов */
        .signals-table {
            background: var(--bg-card);
            border-radius: 1rem;
            overflow: hidden;
            box-shadow: var(--shadow-md);
            border: 1px solid var(--bg-tertiary);
        }

                         .table-header {
            background: var(--bg-tertiary);
            padding: 1rem 1.5rem;
            display: grid;
            grid-template-columns: 0.6fr 1.2fr 1fr 0.8fr 0.8fr 1fr 1fr 1fr 1.2fr 0.9fr 0.9fr 1.1fr 1.1fr 1.2fr;
            gap: 1rem;
            font-weight: 600;
            color: var(--text-secondary);
            text-transform: uppercase;
            font-size: 0.75rem;
            letter-spacing: 0.05em;
        }
 
        .table-row {
            padding: 1rem 1.5rem;
            display: grid;
            grid-template-columns: 0.6fr 1.2fr 1fr 0.8fr 0.8fr 1fr 1fr 1fr 1.2fr 0.9fr 0.9fr 1.1fr 1.1fr 1.2fr;
            gap: 1rem;
            align-items: center;
            border-bottom: 1px solid rgba(0, 255, 65, 0.2);
            border-left: 2px solid transparent;
            transition: var(--transition-normal);
            cursor: pointer;
            position: relative;
        }

        .table-row > div {
            display: flex;
            flex-direction: column;
            gap: 0.15rem;
            min-width: 0;
        }

        .cell-date span:first-child {
            font-weight: 600;
        }

        .cell-date small {
            color: var(--text-muted);
        }

        .table-row::before {
            content: '';
            position: absolute;
            left: 0;
            top: 0;
            bottom: 0;
            width: 2px;
            background: var(--accent-primary);
            transform: scaleY(0);
            transition: transform 0.3s ease;
            box-shadow: var(--neon-glow);
        }

        .table-row:hover {
            background: rgba(0, 255, 65, 0.05);
            border-left-color: var(--accent-primary);
            box-shadow: inset 0 0 20px rgba(0, 255, 65, 0.1);
        }

        .table-row:hover::before {
            transform: scaleY(1);
        }

        .table-row:last-child {
            border-bottom: none;
        }

        /* Модальное окно для графика */
        .modal {
            display: none;
            position: fixed;
            z-index: 10000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(10, 14, 26, 0.95);
            backdrop-filter: blur(5px);
            animation: fadeIn 0.3s ease;
        }

        .modal.active {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .modal-content {
            background: var(--bg-card);
            border-radius: 1rem;
            width: 90%;
            max-width: 1400px;
            max-height: 95vh;
            display: flex;
            flex-direction: column;
            box-shadow: var(--shadow-xl);
            border: 1px solid var(--bg-tertiary);
            overflow-y: auto;
            overflow-x: hidden;
        }

        .modal-header {
            padding: 1rem 1.5rem;   /* более компактный заголовок */
            border-bottom: 1px solid var(--bg-tertiary);
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: var(--bg-secondary);
        }

        .modal-header h2 {
            margin: 0;
            font-size: 1.5rem;
            color: var(--text-primary);
        }

        .modal-header .close {
            color: var(--text-secondary);
            font-size: 2rem;
            font-weight: bold;
            cursor: pointer;
            line-height: 1;
            transition: var(--transition-normal);
        }

        .modal-header .close:hover {
            color: var(--text-primary);
            transform: scale(1.1);
        }

        .modal-body {
            display: flex;
            flex-direction: column;
            padding: 1rem 1.5rem;
        }

        .chart-controls {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 0.5rem;   /* чуть меньше отступ под контролами */
            gap: 1rem;
        }

        .chart-controls select {
            padding: 0.5rem 1rem;
            background: var(--bg-tertiary);
            border: 1px solid var(--bg-tertiary);
            border-radius: 0.5rem;
            color: var(--text-primary);
            font-size: 0.875rem;
            cursor: pointer;
        }

        .signal-info {
            display: flex;
            gap: 1.5rem;
            flex-wrap: wrap;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .signal-info-item {
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
        }

        .signal-info-item strong {
            color: var(--text-primary);
        }

        .chart-container {
            background: var(--bg-secondary);
            border-radius: 0.5rem;
            overflow: hidden;
            position: relative;
            height: 400px;
            min-height: 400px;
        }

        .elder-screens-section {
            margin-top: 1rem;
            background: var(--bg-secondary);
            border-radius: 0.75rem;
            border: 1px solid rgba(255, 255, 255, 0.05);
            padding: 1rem;
        }

        .elder-screens-section .section-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.75rem;
        }

        .elder-screens-section h3 {
            margin: 0;
            font-size: 1rem;
            color: var(--text-primary);
        }

        .elder-screens-content {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }

        .elder-screen-card {
            background: rgba(0, 255, 65, 0.05);
            border: 1px solid rgba(0, 255, 65, 0.2);
            border-radius: 0.5rem;
            padding: 0.75rem;
        }

        .elder-screen-card.blocked {
            background: rgba(255, 0, 110, 0.05);
            border-color: rgba(255, 0, 110, 0.3);
        }

        .elder-screen-card.not-checked {
            background: rgba(237, 137, 54, 0.05);
            border-color: rgba(237, 137, 54, 0.3);
        }

        .elder-screen-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.5rem;
        }

        .elder-screen-title {
            font-weight: bold;
            color: var(--text-primary);
            font-size: 0.95rem;
        }

        .elder-screen-status {
            padding: 0.25rem 0.5rem;
            border-radius: 0.25rem;
            font-size: 0.8rem;
            font-weight: bold;
        }

        .elder-screen-status.passed {
            background: rgba(0, 255, 65, 0.2);
            color: var(--accent-success);
        }

        .elder-screen-status.blocked {
            background: rgba(255, 0, 110, 0.2);
            color: var(--accent-danger);
        }

        .elder-screen-status.not-checked {
            background: rgba(237, 137, 54, 0.2);
            color: var(--accent-warning);
        }

        .elder-screen-details {
            font-size: 0.85rem;
            color: var(--text-secondary);
            margin-top: 0.5rem;
        }

        .elder-screen-details-item {
            margin: 0.25rem 0;
            padding-left: 0.5rem;
            border-left: 2px solid rgba(0, 255, 65, 0.3);
        }

        .elder-screen-details-item.blocked {
            border-left-color: rgba(255, 0, 110, 0.3);
        }

        .live-log-section {
            margin-top: 1rem;
            background: var(--bg-secondary);
            border-radius: 0.75rem;
            border: 1px solid rgba(255, 255, 255, 0.05);
            padding: 1rem;
        }

        .live-log-section .section-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.75rem;
        }

        .live-log-section h3 {
            margin: 0;
            font-size: 1rem;
            color: var(--text-primary);
        }

        .refresh-log-btn {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.15);
            color: var(--text-secondary);
            border-radius: 0.5rem;
            padding: 0.3rem 0.75rem;
            font-size: 0.8rem;
            cursor: pointer;
            transition: var(--transition-normal);
        }

        .refresh-log-btn:hover {
            background: var(--accent-primary);
            color: #fff;
            border-color: var(--accent-primary);
        }

        .live-log-content {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            max-height: none;
            overflow-y: visible;
        }

        .live-log-item {
            display: flex;
            gap: 0.75rem;
            padding: 0.6rem;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 0.5rem;
        }

        .live-log-time {
            font-size: 0.75rem;
            color: var(--text-muted);
            min-width: 70px;
        }

        .live-log-message {
            color: var(--text-primary);
            font-size: 0.85rem;
        }

        .log-placeholder {
            text-align: center;
            color: var(--text-muted);
            padding: 0.5rem 0;
        }

        .progress-indicator {
            margin-top: 0.25rem;     /* уменьшаем вертикальный зазор */
            padding: 0.5rem;         /* более компактный блок прогресса */
            background: var(--bg-secondary);
            border-radius: 0.5rem;
            border: 1px solid var(--bg-tertiary);
            display: flex;
            flex-direction: column;
            gap: 0.35rem;
        }

        .progress-header {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem 1rem;
            justify-content: space-between;
            color: var(--text-secondary);
            font-size: 0.8rem;       /* чуть мельче текст, чтобы блок был ниже */
            font-size: 0.8rem;
        }

        .progress-header strong {
            color: var(--text-primary);
        }

        .progress-bar-wrapper {
            position: relative;
            height: 8px;
            background: var(--bg-tertiary);
            border-radius: 999px;
            overflow: hidden;
        }

        .progress-bar {
            position: absolute;
            top: 0;
            bottom: 0;
            background: linear-gradient(90deg, rgba(0,255,65,0.85), rgba(255,0,110,0.85));
            border-radius: 999px;
            transition: width 0.3s ease;
        }

        .progress-markers {
            display: flex;
            justify-content: space-between;
            font-size: 0.75rem;
            color: var(--text-secondary);
        }

        /* Спиннер для загрузки */
        .spinner {
            width: 40px;
            height: 40px;
            border: 4px solid var(--bg-tertiary);
            border-top: 4px solid var(--accent-primary);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .signal-type {
            padding: 0.25rem 0.75rem;
            border-radius: 1rem;
            font-size: 0.75rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .signal-long {
            background: var(--gradient-success);
            color: white;
        }

        .signal-short {
            background: var(--gradient-danger);
            color: white;
        }

                         .signal-unknown {
            background: var(--gradient-warning);
            color: white;
        }
 
        /* Стили для трендов */
        .trend-strong {
            color: var(--accent-success);
            font-weight: 600;
        }
 
        .trend-weak {
            color: var(--accent-warning);
            font-weight: 600;
        }
 
        .trend-sideways {
            color: var(--accent-info);
            font-weight: 600;
        }
 
        .trend-neutral {
            color: var(--text-muted);
        }
        
        /* Стили для направления тренда */
        .trend-up {
            color: var(--accent-success) !important;
        }
        
        .trend-down {
            color: var(--accent-danger) !important;
        }
        
        .trend-sideways-direction {
            color: var(--accent-info) !important;
        }
 
        /* Стили для результатов */
        .result-profit {
            color: var(--accent-success);
            font-weight: 600;
        }
 
        .result-loss {
            color: var(--accent-danger);
            font-weight: 600;
        }
 
        .result-neutral {
            color: var(--text-muted);
        }

        /* Адаптивность */
        @media (max-width: 768px) {
            .main-content {
                padding: 1rem;
            }
            
            .filters-row {
                flex-direction: column;
                align-items: stretch;
            }
            
            .search-box {
                min-width: auto;
            }
            
            .table-header,
            .table-row {
                grid-template-columns: 1fr;
                gap: 0.5rem;
            }
            
            .table-header {
                display: none;
            }
            
            .table-row {
                border: 1px solid var(--bg-tertiary);
                border-radius: 0.5rem;
                margin-bottom: 0.5rem;
            }
        }

        /* Индикаторы загрузки */
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(10, 14, 26, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 9999;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
        }

        .loading-overlay.active {
            opacity: 1;
            visibility: visible;
        }

        .loading-spinner {
            width: 50px;
            height: 50px;
            border: 3px solid var(--bg-tertiary);
            border-top: 3px solid var(--accent-primary);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .loading-text {
            color: var(--text-primary);
            margin-top: 1rem;
            font-size: 0.875rem;
        }

        /* Индикаторы обновления для карточек */
        .stat-card.updating {
            position: relative;
        }

        .stat-card.updating::after {
            content: '';
            position: absolute;
            top: 0.5rem;
            right: 0.5rem;
            width: 12px;
            height: 12px;
            border: 2px solid var(--bg-tertiary);
            border-top: 2px solid var(--accent-primary);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        /* Плавные переходы для данных */
        .stat-value {
            transition: all 0.3s ease;
        }

        .stat-value.updating {
            opacity: 0.7;
        }

        /* Индикатор обновления для кнопки */
        .btn.updating {
            position: relative;
            pointer-events: none;
        }

        .btn.updating::after {
            content: '';
            position: absolute;
            top: 50%;
            right: 0.75rem;
            transform: translateY(-50%);
            width: 16px;
            height: 16px;
            border: 2px solid transparent;
            border-top: 2px solid currentColor;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        /* Анимации для таблицы */
        .table-row {
            animation: fadeInUp 0.3s ease;
        }

        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* Скелетон для загрузки */
        .skeleton {
            background: linear-gradient(90deg, var(--bg-tertiary) 25%, var(--bg-secondary) 50%, var(--bg-tertiary) 75%);
            background-size: 200% 100%;
            animation: loading 1.5s infinite;
        }

        @keyframes loading {
            0% { background-position: 200% 0; }
            100% { background-position: -200% 0; }
        }

        .skeleton-text {
            height: 1.5rem;
            border-radius: 0.25rem;
            margin-bottom: 0.5rem;
        }

        .skeleton-value {
            height: 2.5rem;
            border-radius: 0.25rem;
            margin-bottom: 1rem;
        }

        /* ============================================
           СТИЛИ ТЕМ
           ============================================ */

        /* Классический стиль */
        body.theme-classic {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        body.theme-classic:root,
        body.theme-classic {
            --bg-primary: #0a0e1a;
            --bg-secondary: #1a1f2e;
            --bg-tertiary: #252a3a;
            --bg-card: #1e2332;
            --bg-modal: rgba(10, 14, 26, 0.95);
            --text-primary: #ffffff;
            --text-secondary: #a0aec0;
            --text-muted: #718096;
            --accent-primary: #667eea;
            --accent-secondary: #764ba2;
            --accent-success: #48bb78;
            --accent-danger: #f56565;
            --accent-warning: #ed8936;
            --accent-info: #4299e1;
            --gradient-primary: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            --gradient-success: linear-gradient(135deg, #48bb78 0%, #38a169 100%);
            --gradient-danger: linear-gradient(135deg, #f56565 0%, #e53e3e 100%);
            --gradient-warning: linear-gradient(135deg, #ed8936 0%, #dd6b20 100%);
            --glass-bg: rgba(30, 35, 50, 0.6);
            --glass-border: rgba(102, 126, 234, 0.3);
            --neon-glow: 0 4px 15px rgba(102, 126, 234, 0.3);
            --neon-glow-pink: 0 4px 15px rgba(118, 75, 162, 0.3);
        }

        body.theme-classic::before,
        body.theme-classic::after {
            display: none;
        }

        body.theme-classic .header {
            background: var(--gradient-primary);
            border-bottom: none;
            box-shadow: var(--shadow-lg);
            overflow: visible;
        }

        body.theme-classic .header::before,
        body.theme-classic .header::after {
            display: none;
        }

        body.theme-classic .logo {
            animation: none;
            filter: none;
        }

        body.theme-classic .header h1 {
            background: linear-gradient(135deg, #ffffff 0%, #e2e8f0 100%);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: none;
            animation: none;
        }

        body.theme-classic .stat-card,
        body.theme-classic .filters-section,
        body.theme-classic .table-header,
        body.theme-classic .table-row {
            background: var(--bg-card);
            border-radius: 1rem;
            border: 1px solid var(--bg-tertiary);
            box-shadow: var(--shadow-md);
        }

        body.theme-classic .stat-card::before,
        body.theme-classic .stat-card::after,
        body.theme-classic .table-header::before,
        body.theme-classic .table-header::after,
        body.theme-classic .table-row::before,
        body.theme-classic .table-row::after {
            display: none;
        }

        body.theme-classic .btn-primary,
        body.theme-classic .btn-secondary,
        body.theme-classic .design-btn,
        body.theme-classic .nav-item {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            text-transform: none;
            letter-spacing: normal;
            border-radius: 0.5rem;
        }

        body.theme-classic .btn-primary {
            background: var(--gradient-primary);
            color: white;
            border: none;
        }

        body.theme-classic .btn-secondary {
            background: var(--bg-tertiary);
            color: var(--text-primary);
            border: 1px solid var(--accent-primary);
        }

        /* Космический стиль */
        body.theme-cosmic {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        body.theme-cosmic:root,
        body.theme-cosmic {
            --bg-primary: #0a0e27;
            --bg-secondary: #14142e;
            --bg-tertiary: #1a1a3e;
            --bg-card: rgba(26, 26, 62, 0.6);
            --bg-modal: rgba(10, 14, 39, 0.95);
            --text-primary: #ffffff;
            --text-secondary: #b8b8d4;
            --text-muted: #6b6b8a;
            --accent-primary: #6c5ce7;
            --accent-secondary: #fdcb6e;
            --accent-success: #00b894;
            --accent-danger: #d63031;
            --accent-warning: #fdcb6e;
            --accent-info: #74b9ff;
            --gradient-primary: linear-gradient(135deg, #6c5ce7 0%, #a29bfe 50%, #fdcb6e 100%);
            --gradient-success: linear-gradient(135deg, #00b894 0%, #00a085 100%);
            --gradient-danger: linear-gradient(135deg, #d63031 0%, #c0392b 100%);
            --gradient-warning: linear-gradient(135deg, #fdcb6e 0%, #f39c12 100%);
            --glass-bg: rgba(26, 26, 62, 0.4);
            --glass-border: rgba(108, 92, 231, 0.3);
            --neon-glow: 0 0 20px rgba(108, 92, 231, 0.4), 0 0 40px rgba(108, 92, 231, 0.2);
            --neon-glow-pink: 0 0 20px rgba(253, 203, 110, 0.4), 0 0 40px rgba(253, 203, 110, 0.2);
        }

        body.theme-cosmic::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-image: 
                radial-gradient(2px 2px at 20% 30%, rgba(108, 92, 231, 0.3), transparent),
                radial-gradient(2px 2px at 60% 70%, rgba(253, 203, 110, 0.2), transparent),
                radial-gradient(1px 1px at 50% 50%, rgba(255, 255, 255, 0.1), transparent);
            background-size: 200% 200%, 150% 150%, 100% 100%;
            animation: starField 20s linear infinite;
            pointer-events: none;
            z-index: 0;
        }

        @keyframes starField {
            0% { background-position: 0% 0%, 0% 0%, 0% 0%; }
            100% { background-position: 100% 100%, 50% 50%, 25% 25%; }
        }

        body.theme-cosmic::after {
            display: none;
        }

        body.theme-cosmic .header {
            background: rgba(10, 14, 39, 0.9);
            backdrop-filter: blur(20px);
            border-bottom: 1px solid rgba(108, 92, 231, 0.3);
            box-shadow: 0 8px 32px rgba(108, 92, 231, 0.2);
            overflow: visible;
        }

        body.theme-cosmic .header::before {
            background: var(--gradient-primary);
            opacity: 0.1;
        }

        body.theme-cosmic .header::after {
            background: linear-gradient(90deg, transparent, rgba(108, 92, 231, 0.3), transparent);
        }

        body.theme-cosmic .logo {
            animation: logoFloat 3s ease-in-out infinite;
            filter: drop-shadow(0 0 15px rgba(108, 92, 231, 0.6));
        }

        @keyframes logoFloat {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-5px); }
        }

        body.theme-cosmic .header h1 {
            background: var(--gradient-primary);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: none;
            animation: none;
        }

        body.theme-cosmic .stat-card,
        body.theme-cosmic .filters-section,
        body.theme-cosmic .table-header,
        body.theme-cosmic .table-row {
            background: var(--glass-bg);
            backdrop-filter: blur(10px);
            border-radius: 1rem;
            border: 1px solid var(--glass-border);
            box-shadow: 0 8px 32px rgba(108, 92, 231, 0.2);
        }

        body.theme-cosmic .stat-card::before {
            background: var(--gradient-primary);
            height: 4px;
            border-radius: 1rem 1rem 0 0;
        }

        body.theme-cosmic .stat-card::after,
        body.theme-cosmic .table-header::before,
        body.theme-cosmic .table-header::after,
        body.theme-cosmic .table-row::before,
        body.theme-cosmic .table-row::after {
            display: none;
        }

        body.theme-cosmic .btn-primary {
            background: var(--glass-bg);
            backdrop-filter: blur(10px);
            color: var(--accent-primary);
            border: 1px solid var(--glass-border);
        }

        body.theme-cosmic .btn-secondary {
            background: var(--glass-bg);
            backdrop-filter: blur(10px);
            color: var(--accent-secondary);
            border: 1px solid rgba(253, 203, 110, 0.3);
        }

        body.theme-cosmic .nav-item,
        body.theme-cosmic .design-btn {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            text-transform: none;
            letter-spacing: normal;
        }

        /* Специфичные стили для меню в космической теме */
        body.theme-cosmic .header-content {
            overflow: visible;
            z-index: 10003;
        }

        body.theme-cosmic .header-controls {
            overflow: visible;
            z-index: 10003;
        }

        body.theme-cosmic .nav-menu {
            overflow: visible;
            z-index: 10003;
        }

        body.theme-cosmic .design-dropdown {
            z-index: 10004;
            overflow: visible;
        }

        body.theme-cosmic .design-menu {
            z-index: 99999 !important;
            overflow: visible !important;
            position: fixed !important;
        }

        body.theme-cosmic .design-menu.active {
            display: block !important;
        }

        /* Стили для меню, перемещенного в body для космической темы */
        .cosmic-menu-portal {
            position: fixed !important;
            z-index: 99999 !important;
            background: rgba(0, 0, 0, 0.95) !important;
            border: 2px solid var(--accent-primary) !important;
            box-shadow: var(--neon-glow) !important;
            min-width: 200px !important;
        }

        /* Убеждаемся, что body и html не обрезают меню в космической теме */
        body.theme-cosmic,
        html.theme-cosmic {
            overflow-x: hidden;
            overflow-y: auto;
        }

        body.theme-cosmic .main-content {
            position: relative;
            z-index: 1;
        }
    </style>
</head>
<body class="theme-cyberpunk">
    <!-- Индикатор загрузки -->
    <div class="loading-overlay" id="loading-overlay">
        <div style="text-align: center;">
            <div class="loading-spinner"></div>
            <div class="loading-text" id="loading-text">Загрузка данных...</div>
        </div>
    </div>

    <!-- Заголовок -->
    <header class="header">
        <div class="header-content">
            <div class="logo-container">
                <div class="logo">
                    <svg viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
                        <defs>
                            <linearGradient id="logoGradient" x1="0%" y1="0%" x2="100%" y2="100%">
                                <stop offset="0%" style="stop-color:#00ff41;stop-opacity:1" />
                                <stop offset="50%" style="stop-color:#00cc33;stop-opacity:1" />
                                <stop offset="100%" style="stop-color:#ff006e;stop-opacity:1" />
                            </linearGradient>
                            <filter id="glow">
                                <feGaussianBlur stdDeviation="4" result="coloredBlur"/>
                                <feMerge>
                                    <feMergeNode in="coloredBlur"/>
                                    <feMergeNode in="SourceGraphic"/>
                                </feMerge>
                            </filter>
                        </defs>
                        <!-- Цифровой/матричный символ -->
                        <rect x="20" y="20" width="60" height="60" fill="none" stroke="url(#logoGradient)" stroke-width="3" filter="url(#glow)"/>
                        <rect x="30" y="30" width="40" height="40" fill="none" stroke="url(#logoGradient)" stroke-width="2" filter="url(#glow)"/>
                        <line x1="20" y1="50" x2="30" y2="50" stroke="url(#logoGradient)" stroke-width="2" filter="url(#glow)"/>
                        <line x1="70" y1="50" x2="80" y2="50" stroke="url(#logoGradient)" stroke-width="2" filter="url(#glow)"/>
                        <line x1="50" y1="20" x2="50" y2="30" stroke="url(#logoGradient)" stroke-width="2" filter="url(#glow)"/>
                        <line x1="50" y1="70" x2="50" y2="80" stroke="url(#logoGradient)" stroke-width="2" filter="url(#glow)"/>
                        <circle cx="50" cy="50" r="5" fill="url(#logoGradient)" filter="url(#glow)"/>
                        <!-- Цифровые линии -->
                        <path d="M25 25 L35 35 M65 25 L75 35 M25 75 L35 65 M65 75 L75 65" stroke="url(#logoGradient)" stroke-width="1.5" opacity="0.7" filter="url(#glow)"/>
                    </svg>
                </div>
                <h1>OwnedCore</h1>
            </div>
            <div class="header-controls">
                <nav class="nav-menu">
                    <a href="/dashboard" class="nav-item" id="nav-dashboard">Дашборд</a>
                    <a href="/charts" class="nav-item" id="nav-charts">Графики</a>
                    <a href="/signals" class="nav-item" id="nav-signals">Сигналы</a>
                    <a href="/potential-signals" class="nav-item" id="nav-potential">ES</a>
                    <a href="/demo-trading" class="nav-item" id="nav-demo">Демо</a>
                    <div class="design-dropdown">
                        <button class="design-btn" onclick="toggleDesignMenu()">Дизайн</button>
                        <div class="design-menu" id="design-menu">
                            <div class="design-option" onclick="switchTheme('classic')" data-theme="classic">Классический</div>
                            <div class="design-option active" onclick="switchTheme('cyberpunk')" data-theme="cyberpunk">Cyberpunk</div>
                            <div class="design-option" onclick="switchTheme('cosmic')" data-theme="cosmic">Космический</div>
                        </div>
                    </div>
                </nav>
                <button id="live-trading-toggle" class="live-toggle-btn live-on" onclick="toggleLiveTrading(event)">
                    LIVE: ВКЛ
                </button>
            </div>
        </div>
    </header>

    <!-- Основной контент -->
    <main class="main-content">
        <!-- Статистика: реальные сделки (исполненные ордера) -->
        <div class="stats-section">
            <!-- Результат по периодам -->
            <div class="stats-grid">
                <div class="stat-card" id="real-today-result-card">
                    <div class="stat-value" id="real-today-result">-</div>
                    <div class="stat-label">Сегодня</div>
                </div>
                <div class="stat-card" id="real-week-result-card">
                    <div class="stat-value" id="real-week-result">-</div>
                    <div class="stat-label">За неделю</div>
                </div>
                <div class="stat-card" id="real-month-result-card">
                    <div class="stat-value" id="real-month-result">-</div>
                    <div class="stat-label">За месяц</div>
                </div>
            </div>
            
            <!-- Сводка по сделкам -->
            <div class="stats-grid">
                <div class="stat-card" id="real-profit-signals-card">
                    <div class="stat-value" id="real-profit-signals">-</div>
                    <div class="stat-label">Прибыльных</div>
                </div>
                <div class="stat-card" id="real-loss-signals-card">
                    <div class="stat-value" id="real-loss-signals">-</div>
                    <div class="stat-label">Убыточных</div>
                </div>
                <div class="stat-card" id="real-in-progress-signals-card">
                    <div class="stat-value" id="real-in-progress-signals">-</div>
                    <div class="stat-label">Открытых</div>
                </div>
                <div class="stat-card" id="not-executed-signals-card">
                    <div class="stat-value" id="not-executed-signals">-</div>
                    <div class="stat-label">Неотработанных</div>
                </div>
            </div>
        </div>

        <!-- Фильтры -->
        <div class="filters-section">
            <div class="filters-row">
                <div class="search-box">
                    <span class="search-icon">🔍</span>
                    <input type="text" class="search-input" id="search-input" placeholder="Поиск по парам..." onkeyup="filterSignals()">
                </div>
                <div class="filter-buttons">
                    <button class="filter-btn active" onclick="filterByType('all')">Все</button>
                    <button class="filter-btn" onclick="filterByType('LONG')">Long</button>
                    <button class="filter-btn" onclick="filterByType('SHORT')">Short</button>
                </div>
            </div>
            <div class="filters-row">
                <div class="filter-buttons">
                    <button class="filter-btn" onclick="filterByPeriod('all')">Все время</button>
                    <button class="filter-btn" onclick="filterByPeriod('today')">Сегодня</button>
                    <button class="filter-btn" onclick="filterByPeriod('week')">Неделя</button>
                    <button class="filter-btn" onclick="filterByPeriod('month')">Месяц</button>
                </div>
            </div>
        </div>

                 <!-- Таблица сигналов -->
         <div class="signals-table">
             <div class="table-header">
                 <div>ID</div>
                 <div>Дата/Время</div>
                 <div>Пара</div>
                 <div>ТФ</div>
                 <div>Тип</div>
                 <div>Уровень</div>
                 <div>Вход</div>
                 <div>Stop Loss</div>
                 <div>Hist / Live</div>
                 <div>Score / Dist</div>
                 <div>Тренд</div>
                 <div>Макс. движение</div>
                 <div>Результат</div>
                 <div>Live статус</div>
             </div>
            <div id="signals-table-body">
                <div style="padding: 2rem; text-align: center; color: var(--text-muted);">
                    Загрузка сигналов...
                </div>
            </div>
        </div>
    </main>

    <!-- Модальное окно с графиком сигнала -->
    <div id="signal-chart-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 id="signal-modal-title">График сигнала</h2>
                <span class="close" onclick="closeSignalChart()">&times;</span>
            </div>
            <div class="modal-body">
                <div class="chart-controls">
                    <select id="signal-timeframe-selector" onchange="changeSignalTimeframe()">
                        <option value="5m">5 минут</option>
                        <option value="15m" selected>15 минут</option>
                        <option value="1h">1 час</option>
                        <option value="4h">4 часа</option>
                    </select>
                    <div class="signal-info" id="signal-info">
                        <!-- Информация о сигнале будет здесь -->
                    </div>
                </div>
                <div id="signal-chart-container" class="chart-container">
                    <!-- График будет здесь -->
                </div>
                <div id="elder-screens-section" class="elder-screens-section">
                    <div class="section-header">
                        <h3>Система трех экранов Элдера</h3>
                    </div>
                    <div id="elder-screens-content" class="elder-screens-content">
                        <div class="log-placeholder">Загрузка данных...</div>
                    </div>
                </div>
                <div id="live-log-section" class="live-log-section">
                    <div class="section-header">
                        <h3>Ход сделки</h3>
                        <button class="refresh-log-btn" onclick="loadSignalLiveLog(currentSignalId)">Обновить</button>
                    </div>
                    <div id="live-log-content" class="live-log-content">
                        <div class="log-placeholder">Загрузка истории...</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        let allSignals = [];
        let filteredSignals = [];
        let isLoading = false;
        let lastUpdateTime = null;
        let liveTradingEnabled = true;
        const serverPort = window.location.port || '8000';
        const baseUrl = `http://localhost:${serverPort}`;
        
        // Глобальные переменные для графика
        let currentSignalChart = null;
        let currentSignalId = null;
        let currentSignalData = null;
        let signalChartResizeObserver = null;
        let signalAutoRefreshTimer = null;
        let currentCandlestickSeries = null; // Серия свечей для обновления без пересоздания
        let currentEntryLineSeries = null; // Линия входа
        let currentExitLineSeries = null; // Линия выхода

        // ============================================================================
        // ФУНКЦИИ ФОРМАТИРОВАНИЯ ВРЕМЕНИ (МОСКОВСКОЕ ВРЕМЯ UTC+3)
        // ============================================================================
        
        /**
         * Форматирует дату и время в московском часовом поясе (UTC+3)
         * @param {string|Date} dateString - ISO строка или Date объект
         * @returns {string} - Отформатированная строка в формате "DD.MM.YYYY, HH:MM:SS"
         */
        function formatMoscowTime(dateString) {
            if (!dateString) return 'N/A';
            
            try {
                const date = typeof dateString === 'string' ? new Date(dateString) : dateString;
                if (isNaN(date.getTime())) return 'N/A';
                
                // Используем Intl для корректного отображения в московском времени
                return date.toLocaleString('ru-RU', {
                    timeZone: 'Europe/Moscow',
                    year: 'numeric',
                    month: '2-digit',
                    day: '2-digit',
                    hour: '2-digit',
                    minute: '2-digit',
                    second: '2-digit',
                    hour12: false
                });
            } catch (e) {
                console.warn('Ошибка форматирования времени:', e);
                return 'N/A';
            }
        }
        
        /**
         * Форматирует только дату в московском часовом поясе
         * @param {string|Date} dateString - ISO строка или Date объект
         * @returns {string} - Отформатированная дата в формате "DD.MM.YYYY"
         */
        function formatMoscowDate(dateString) {
            if (!dateString) return 'N/A';
            
            try {
                const date = typeof dateString === 'string' ? new Date(dateString) : dateString;
                if (isNaN(date.getTime())) return 'N/A';
                
                return date.toLocaleDateString('ru-RU', {
                    timeZone: 'Europe/Moscow',
                    year: 'numeric',
                    month: '2-digit',
                    day: '2-digit'
                });
            } catch (e) {
                console.warn('Ошибка форматирования даты:', e);
                return 'N/A';
            }
        }
        
        /**
         * Форматирует только время в московском часовом поясе
         * @param {string|Date} dateString - ISO строка или Date объект
         * @returns {string} - Отформатированное время в формате "HH:MM:SS"
         */
        function formatMoscowTimeOnly(dateString) {
            if (!dateString) return 'N/A';
            
            try {
                const date = typeof dateString === 'string' ? new Date(dateString) : dateString;
                if (isNaN(date.getTime())) return 'N/A';
                
                return date.toLocaleTimeString('ru-RU', {
                    timeZone: 'Europe/Moscow',
                    hour: '2-digit',
                    minute: '2-digit',
                    second: '2-digit',
                    hour12: false
                });
            } catch (e) {
                console.warn('Ошибка форматирования времени:', e);
                return 'N/A';
            }
        }

        function updateLiveTradingToggleButton() {
            const btn = document.getElementById('live-trading-toggle');
            if (!btn) return;
            btn.classList.toggle('live-on', liveTradingEnabled);
            btn.classList.toggle('live-off', !liveTradingEnabled);
            btn.textContent = liveTradingEnabled ? 'LIVE: ВКЛ' : 'LIVE: ВЫКЛ';
        }

        async function fetchLiveTradingStatus() {
            try {
                const response = await fetch(`${baseUrl}/api/trading/live/status`);
                const data = await response.json();
                if (typeof data.enabled === 'boolean') {
                    liveTradingEnabled = data.enabled;
                    updateLiveTradingToggleButton();
                }
            } catch (error) {
                console.warn('Не удалось получить статус live-торговли:', error);
            }
        }

        async function toggleLiveTrading(event) {
            if (event) {
                event.preventDefault();
                event.stopPropagation();
            }
            try {
                const response = await fetch(`${baseUrl}/api/trading/live/status`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ enabled: !liveTradingEnabled })
                });
                const data = await response.json();
                if (typeof data.enabled === 'boolean') {
                    liveTradingEnabled = data.enabled;
                    updateLiveTradingToggleButton();
                }
            } catch (error) {
                console.error('Не удалось переключить live-режим:', error);
            }
        }

        // Инициализация
        document.addEventListener('DOMContentLoaded', function() {
            fetchLiveTradingStatus();
            // Сначала пытаемся загрузить из кэша
            const cacheLoaded = loadFromCache();
            
            // Если кэш загружен успешно, обновляем данные в фоне без показа индикатора
            if (cacheLoaded) {
                loadSignals(false); // false = не показывать индикатор загрузки
            } else {
                // Если кэша нет, показываем индикатор загрузки
                loadSignals(true);
            }
            
            // Запускаем автообновление
            startAutoRefresh();
        });

        // Загрузка данных из кэша
        function loadFromCache() {
            try {
                const cached = localStorage.getItem('signals_cache');
                const cacheTime = localStorage.getItem('signals_cache_time');
                
                if (cached && cacheTime) {
                    const data = JSON.parse(cached);
                    const cacheAge = Date.now() - parseInt(cacheTime);
                    
                    // Используем кэш, если он не старше 10 минут (увеличено с 5)
                    if (cacheAge < 10 * 60 * 1000) {
                        console.log('Загружаем данные из кэша');
                        allSignals = data.signals || [];
                        filteredSignals = [...allSignals];
                        updateStats(data);
                        updateSignalsTable();
                        lastUpdateTime = new Date(parseInt(cacheTime));
                        return true;
                    }
                }
            } catch (error) {
                console.warn('Ошибка загрузки кэша:', error);
            }
            return false;
        }

        // Сохранение данных в кэш
        function saveToCache(data) {
            try {
                localStorage.setItem('signals_cache', JSON.stringify(data));
                localStorage.setItem('signals_cache_time', Date.now().toString());
                console.log('Данные сохранены в кэш');
            } catch (error) {
                console.warn('Ошибка сохранения кэша:', error);
            }
        }

        // Показ индикатора загрузки
        function showLoadingIndicator(text = 'Загрузка данных...') {
            const overlay = document.getElementById('loading-overlay');
            const loadingText = document.getElementById('loading-text');
            loadingText.textContent = text;
            overlay.classList.add('active');
        }

        // Скрытие индикатора загрузки
        function hideLoadingIndicator() {
            const overlay = document.getElementById('loading-overlay');
            overlay.classList.remove('active');
        }

        // Показ индикатора обновления для карточек
        function showCardUpdating(cardId) {
            const card = document.getElementById(cardId);
            if (card) {
                card.classList.add('updating');
            }
        }

        // Скрытие индикатора обновления для карточек
        function hideCardUpdating(cardId) {
            const card = document.getElementById(cardId);
            if (card) {
                card.classList.remove('updating');
            }
        }

        // Показ индикатора обновления для кнопки
        function showButtonUpdating() {
            const btn = document.getElementById('refresh-btn');
            if (btn) {
                btn.classList.add('updating');
                btn.disabled = true;
            }
        }

        // Скрытие индикатора обновления для кнопки
        function hideButtonUpdating() {
            const btn = document.getElementById('refresh-btn');
            if (btn) {
                btn.classList.remove('updating');
                btn.disabled = false;
            }
        }

        // Загрузка сигналов с кэшированием
        async function loadSignals(showLoading = false) {
            if (isLoading) {
                console.log('Загрузка уже идет, пропускаем');
                return;
            }

            isLoading = true;
            
            if (showLoading) {
                showLoadingIndicator('Загрузка сигналов...');
            } else {
                showButtonUpdating();
            }

            try {
                const response = await fetch(`${baseUrl}/api/signals`);
                const data = await response.json();
                
                if (data.success) {
                    allSignals = data.signals || [];
                    filteredSignals = [...allSignals];
                    
                    // Сохраняем в кэш
                    saveToCache(data);
                    
                    // Обновляем интерфейс
                    updateStats(data);
                    updateSignalsTable();
                    
                    lastUpdateTime = new Date();
                    console.log('Данные успешно загружены');
                    
                    // Проверяем, есть ли сигналы без результатов P&L
                    const signalsWithoutResults = allSignals.filter(s => 
                        !s.calculated_result && (!s.max_favorable_move || s.max_favorable_move === 0)
                    );
                    
                    // Если есть сигналы без результатов, запускаем обновление P&L
                    if (signalsWithoutResults.length > 0) {
                        console.log(`Найдено ${signalsWithoutResults.length} сигналов без результатов, запускаем обновление P&L...`);
                        fetch(`${baseUrl}/api/update-signals-pnl`, { method: 'POST' })
                            .then(res => res.json())
                            .then(data => {
                                console.log('Обновление P&L запущено:', data);
                                // Подождем 10 секунд и обновим данные
                                setTimeout(() => {
                                    loadSignals(false);
                                }, 10000);
                            })
                            .catch(err => console.error('Ошибка запуска обновления P&L:', err));
                    }
                } else {
                    throw new Error(data.error || 'Ошибка загрузки данных');
                }
            } catch (error) {
                console.error('Ошибка загрузки сигналов:', error);
                
                // Если нет кэша, показываем ошибку
                if (!loadFromCache()) {
                    document.getElementById('signals-table-body').innerHTML = 
                        '<div style="padding: 2rem; text-align: center; color: #f56565;">Ошибка загрузки сигналов</div>';
                }
            } finally {
                isLoading = false;
                hideLoadingIndicator();
                hideButtonUpdating();
            }
        }

        // Обновление статистики с анимацией (только реальная статистика)
        function updateStats(data) {
            const signals = data.signals || [];
            const summary = data.summary || {};
            
            // Показываем индикаторы обновления
            const cardIds = [
                'real-profit-signals-card', 'real-loss-signals-card', 'real-in-progress-signals-card',
                'not-executed-signals-card', 'real-today-result-card', 'real-week-result-card', 'real-month-result-card'
            ];
            
            cardIds.forEach(id => showCardUpdating(id));
            
            // Обновляем данные с небольшой задержкой для плавности
            setTimeout(() => {
                // Реальная статистика (исполненные ордера)
                document.getElementById('real-profit-signals').textContent = summary.real_profit_count || 0;
                document.getElementById('real-loss-signals').textContent = summary.real_loss_count || 0;
                document.getElementById('real-in-progress-signals').textContent = summary.real_in_progress_count || 0;
                document.getElementById('not-executed-signals').textContent = summary.not_executed_count || 0;
                
                setRealResult('real-today-result', summary.real_today_result_pct, summary.real_today_result_usdt);
                setRealResult('real-week-result', summary.real_week_result_pct, summary.real_week_result_usdt);
                setRealResult('real-month-result', summary.real_month_result_pct, summary.real_month_result_usdt);
                
                // Скрываем индикаторы обновления
                cardIds.forEach(id => hideCardUpdating(id));
                
                // Отладочная информация
                console.log('Статистика реальных сделок:', summary);
                console.log('Всего сигналов:', signals.length);
            }, 100);
        }
        
        function setRealResult(id, pctValue, usdtValue) {
            const el = document.getElementById(id);
            if (!el) return;
            let pct = Number(pctValue || 0);
            let usdt = Number(usdtValue || 0);
            let color = pct > 0 ? 'var(--accent-success)' : pct < 0 ? 'var(--accent-danger)' : 'var(--text-muted)';
            let sign = pct > 0 ? '+' : '';
            el.innerHTML = `
                <div style="color:${color};">
                    <div style="font-size: 1.5rem; font-weight: bold;">${sign}${pct.toFixed(2)}%</div>
                    <div style="font-size: 0.9rem; margin-top: 0.25rem; opacity: 0.8;">${sign}${usdt.toFixed(2)} USDT</div>
                </div>
            `;
        }

        // Обновление таблицы сигналов с анимацией
        function updateSignalsTable() {
            const tableBody = document.getElementById('signals-table-body');
            
            if (filteredSignals.length === 0) {
                tableBody.innerHTML = '<div style="padding: 2rem; text-align: center; color: var(--text-muted);">Нет сигналов для отображения</div>';
                return;
            }

            // Сохраняем текущие строки для сравнения
            const existingRows = Array.from(tableBody.children);
            const existingSignalsMap = new Map();
            
            existingRows.forEach((row) => {
                const signalId = row.dataset.signalId;
                if (signalId) {
                    existingSignalsMap.set(parseInt(signalId), row);
                }
            });

            // Определяем, какие строки нужно обновить, добавить или удалить
            const signalsToUpdate = [];
            const signalsToAdd = [];
            const existingIds = new Set();
            const newRowsMap = new Map();

            // Создаем новые строки и сравниваем
            filteredSignals.forEach((signal, index) => {
                const signalId = signal.id;
                if (!signalId) return; // Пропускаем сигналы без ID
                
                existingIds.add(signalId);
                
                // Создаем HTML для новой строки
                const newRowHTML = createSignalRow(signal);
                const tempDiv = document.createElement('div');
                tempDiv.innerHTML = newRowHTML;
                const newRow = tempDiv.firstElementChild;
                newRowsMap.set(signalId, { element: newRow, index });
                
                const existingRow = existingSignalsMap.get(signalId);
                
                if (existingRow) {
                    // Строка существует - проверяем, нужно ли обновить
                    // Сравниваем ключевые поля, которые могут изменяться
                    const oldHTML = existingRow.innerHTML;
                    const newHTML = newRow.innerHTML;
                    
                    if (oldHTML !== newHTML) {
                        signalsToUpdate.push({ signalId, newRow });
                    }
                } else {
                    // Новая строка - добавляем
                    signalsToAdd.push({ signalId, index });
                }
            });

            // Удаляем строки, которых больше нет
            existingRows.forEach(row => {
                const signalId = parseInt(row.dataset.signalId);
                if (signalId && !existingIds.has(signalId)) {
                    row.remove();
                }
            });

            // Обновляем измененные строки
            signalsToUpdate.forEach(({ signalId, newRow }) => {
                const existingRow = existingSignalsMap.get(signalId);
                if (existingRow) {
                    existingRow.replaceWith(newRow);
                }
            });

            // Добавляем новые строки в правильном порядке
            signalsToAdd.sort((a, b) => a.index - b.index);
            signalsToAdd.forEach(({ signalId, index }) => {
                const rowData = newRowsMap.get(signalId);
                if (!rowData) return;
                
                const newRow = rowData.element;
                
                // Находим правильную позицию для вставки
                if (index === 0) {
                    tableBody.insertBefore(newRow, tableBody.firstChild);
                } else {
                    // Ищем предыдущую строку по индексу
                    let insertBefore = null;
                    for (let i = index - 1; i >= 0; i--) {
                        const prevSignalId = filteredSignals[i]?.id;
                        if (prevSignalId) {
                            const prevRow = tableBody.querySelector(`[data-signal-id="${prevSignalId}"]`);
                            if (prevRow) {
                                insertBefore = prevRow.nextSibling;
                                break;
                            }
                        }
                    }
                    
                    if (insertBefore) {
                        tableBody.insertBefore(newRow, insertBefore);
                    } else {
                        tableBody.appendChild(newRow);
                    }
                }
            });
        }

        function getTradeStatusHtml(signal) {
            const statusRaw = (signal.demo_status || 'NOT_SENT').toUpperCase();
            let text = 'Не отправлен';
            let cls = 'trade-status';

            switch (statusRaw) {
                case 'PLACED':
                case 'FILLED':
                case 'NEW':
                case 'SUBMITTING':
                case 'OPEN_POSITION':
                    text = 'Отправлен';
                    cls += ' trade-status-success';
                    break;
                case 'FAILED':
                case 'CANCELLED':
                case 'ORDER_CANCELLED_PRICE_MOVED':
                    text = 'Ошибка/Отмена';
                    cls += ' trade-status-failed';
                    break;
                case 'LIVE_DISABLED':
                    text = 'Выключено';
                    cls += ' trade-status-disabled';
                    break;
                case 'NOT_CONFIGURED':
                    text = 'API не настроен';
                    cls += ' trade-status-disabled';
                    break;
                case 'INVALID_ENTRY':
                case 'INVALID_QUANTITY':
                case 'INVALID_MARKET_PRICE':
                case 'SIGNAL_TOO_OLD':
                    text = 'Пропущен';
                    cls += ' trade-status-disabled';
                    break;
                case 'WAITING_FOR_PRICE':
                    text = 'Ожидание цены';
                    cls += ' trade-status-warning';
                    break;
                case 'PRICE_DEVIATION_TOO_LARGE':
                    text = 'Цена ушла';
                    cls += ' trade-status-warning';
                    break;
                case 'LEVEL_BROKEN':
                    text = 'Уровень пробит';
                    cls += ' trade-status-failed';
                    break;
                case 'SIGNAL_CLOSED_NO_ORDER':
                    text = 'Закрыт без ордера';
                    cls += ' trade-status-disabled';
                    break;
                case 'POSITION_ALREADY_OPEN':
                    text = 'Уже есть сделка';
                    cls += ' trade-status-info';
                    break;
                case 'SL_TO_BREAKEVEN':
                    text = 'SL в безубытке';
                    cls += ' trade-status-info';
                    break;
                default:
                    if (statusRaw !== 'NOT_SENT') {
                        text = statusRaw;
                    }
            }

            const metaLines = [];

            if (signal.demo_order_id && statusRaw !== 'FAILED') {
                metaLines.push(`ID: ${signal.demo_order_id}`);
            }
            if (signal.demo_error) {
                metaLines.push(signal.demo_error);
            }
            if (signal.demo_updated_at) {
                metaLines.push(`Обновлено ${formatMoscowTimeOnly(signal.demo_updated_at)}`);
            }

            const metaHtml = metaLines.length
                ? `<div class="trade-status-meta">${metaLines.map(line => `<span>${line}</span>`).join('')}</div>`
                : '';

            return `<div class="${cls}"><span class="trade-status-main">${text}</span>${metaHtml}</div>`;
        }

        // Создание строки сигнала
        function createSignalRow(signal) {
            const timestamp = signal.timestamp || signal.created_at || new Date().toISOString();
            const dateStr = formatMoscowDate(timestamp);
            const timeStr = formatMoscowTimeOnly(timestamp);
            
            const signalType = signal.signal_type || signal.type || 'UNKNOWN';
            const signalClass = signalType === 'LONG' ? 'signal-long' : 
                              signalType === 'SHORT' ? 'signal-short' : 'signal-unknown';
            const status = (signal.status || 'ACTIVE').toUpperCase();
            const exitReason = signal.exit_reason ? signal.exit_reason.replace('_', ' ') : '';
            const timeframe = (signal.timeframe || signal.metadata?.timeframe || '15m').toUpperCase();
            const historicalTouches = signal.historical_touches ?? signal.metadata?.historical_touches ?? signal.test_count ?? 0;
            const liveTouches = signal.live_test_count ?? signal.metadata?.live_test_count ?? 0;
            const levelScore = signal.level_score ?? signal.metadata?.level_score ?? signal.metadata?.score ?? null;
            const distancePercent = signal.distance_percent ?? signal.metadata?.distance_percent ?? null;
            const scoreDisplay = levelScore !== null && levelScore !== undefined ? Number(levelScore).toFixed(1) : '—';
            const distanceDisplay = distancePercent !== null && distancePercent !== undefined ? `${Number(distancePercent).toFixed(2)}%` : '—';
            
            const levelPrice = signal.level_price || signal.price || 0;
            const entryPrice = signal.entry_price || signal.current_price || levelPrice;
            
            // Всегда вычисляем Stop Loss от цены входа
            let stopLoss = 0;
            let stopLossDisplay = '$0.0000';
            
            if (entryPrice > 0) {
                const signalType = signal.signal_type || signal.type || 'UNKNOWN';
                const isLong = signalType === 'LONG';
                const stopLossPercent = 0.005; // 0.5%
                
                if (isLong) {
                    stopLoss = entryPrice * (1 - stopLossPercent); // Ниже цены входа
                } else {
                    stopLoss = entryPrice * (1 + stopLossPercent); // Выше цены входа
                }
                
                const stopLossClass = isLong ? 'text-red-500' : 'text-green-500';
                stopLossDisplay = `<span class="${stopLossClass}">$${stopLoss.toFixed(4)}</span>`;
            }
            
            // Отображение максимального движения (будет вычислено позже вместе с результатом)
            let maxMoveDisplay = 'Н/Д';
            
            // Отображение тренда (4H из Elder's Screens)
            let trendDisplay = '';
            let trendClass = 'trend-neutral';
            
            // ИЗМЕНЕНО: Получаем тренд из Elder's Screens (4H), а не из 1H
            let trend = '';
            let trend4h = null;
            
            // Пытаемся получить тренд 4H из Elder's Screens
            if (signal.elder_screens_metadata) {
                const screen1 = signal.elder_screens_metadata.screen_1 || {};
                const pairTrendData = screen1.pair_trend_data || screen1.checks?.pair_trend || null;
                
                if (pairTrendData && pairTrendData.trend) {
                    trend4h = pairTrendData;
                    // Формируем тренд в формате "UP_STRONG", "DOWN_WEAK" и т.д.
                    const trendDirection = pairTrendData.trend; // "UP", "DOWN", "SIDEWAYS"
                    const trendStrength = pairTrendData.strength || 'WEAK'; // "STRONG", "WEAK", "SIDEWAYS"
                    trend = `${trendDirection}_${trendStrength}`;
                }
            }
            
            // Fallback на старый формат, если Elder's Screens нет
            if (!trend) {
                trend = signal['1h_trend'] || signal.trend_1h || '';
            }
            
            if (trend) {
                const parts = trend.split('_');
                const direction = parts[0];
                const strength = parts[1];
                
                let directionText = '';
                let strengthText = '';
                
                // Определяем направление
                if (direction === 'UP') {
                    directionText = 'Восходящий';
                } else if (direction === 'DOWN') {
                    directionText = 'Нисходящий';
                } else {
                    directionText = 'Боковой';
                }
                
                // Определяем силу
                if (strength === 'STRONG') {
                    strengthText = 'СИЛЬНЫЙ';
                } else if (strength === 'WEAK') {
                    strengthText = 'СЛАБЫЙ';
                } else {
                    strengthText = 'СРЕДНИЙ';
                }
                
                // Добавляем пометку "4H" если используем тренд из Elder's Screens
                trendDisplay = trend4h ? `${directionText}, ${strengthText} (4H)` : `${directionText}, ${strengthText}`;
                
                // Определяем CSS класс на основе направления и силы
                let directionClass = '';
                if (direction === 'UP') {
                    directionClass = 'trend-up';
                } else if (direction === 'DOWN') {
                    directionClass = 'trend-down';
                } else {
                    directionClass = 'trend-sideways-direction';
                }
                
                let strengthClass = '';
                if (strength === 'STRONG') {
                    strengthClass = 'trend-strong';
                } else if (strength === 'WEAK') {
                    strengthClass = 'trend-weak';
                } else {
                    strengthClass = 'trend-sideways';
                }
                
                // Комбинируем классы: направление + сила
                trendClass = `${directionClass} ${strengthClass}`;
            } else {
                trendDisplay = 'Н/Д';
                trendClass = 'trend-neutral';
            }
            
            // Отображение результата
            // Рассчитываем фактический результат ТОЛЬКО если ордер был отправлен на биржу (есть demo_order_id)
            // Если нет demo_order_id, значит ордер не был отправлен, и результата быть не должно
            let calculatedResult = 0;
            if (signal.demo_order_id && signal.entry_price && signal.exit_price) {
                // Ордер был отправлен и исполнен - рассчитываем результат
                const entryPrice = parseFloat(signal.entry_price);
                const exitPrice = parseFloat(signal.exit_price);
                if (entryPrice > 0 && exitPrice > 0) {
                    if (signal.signal_type === 'LONG') {
                        calculatedResult = ((exitPrice - entryPrice) / entryPrice) * 100.0;
                    } else { // SHORT
                        calculatedResult = ((entryPrice - exitPrice) / entryPrice) * 100.0;
                    }
                    console.log(`Фактический результат для сигнала ${signal.id}: ${calculatedResult.toFixed(2)}% (entry: ${entryPrice}, exit: ${exitPrice}, type: ${signal.signal_type})`);
                }
            } else if (!signal.demo_order_id && (signal.entry_price || signal.exit_price)) {
                // Ордер не был отправлен, но есть entry_price/exit_price - это теоретический расчет, не показываем
                calculatedResult = 0;
                console.log(`Сигнал ${signal.id}: нет demo_order_id, результат не рассчитывается`);
            } else {
                // Fallback для старых сигналов без live-торговли
                calculatedResult = signal.calculated_result !== undefined && signal.calculated_result !== null 
                    ? parseFloat(signal.calculated_result) : 0;
            }
            const maxFavorable = parseFloat(signal.max_favorable_move) || 0;
            const maxAdverse = parseFloat(signal.max_adverse_move) || 0;
            const pnlPercent = parseFloat(signal.pnl_percent) || 0;
            
            // Обновляем maxMoveDisplay используя вычисленные значения
            // Формат всегда: "+X% / -Y%" где:
            // - X = процент изменения по росту стоимости пары (вверх)
            // - Y = процент изменения до ближайшей минимальной точки (вниз)
            // 
            // Теперь max_favorable_move и max_adverse_move уже правильно вычислены на бэкенде:
            // - max_favorable_move = рост цены вверх (для отображения "+X%")
            // - max_adverse_move = падение цены вниз (для отображения "-Y%")
            if (maxFavorable !== 0 || maxAdverse !== 0) {
                // Формат одинаковый для LONG и SHORT: "+рост% / -падение%"
                maxMoveDisplay = `+${maxFavorable.toFixed(2)}% / -${maxAdverse.toFixed(2)}%`;
            }
            
            let resultDisplay = '';
            let resultClass = 'result-neutral';
            
            // Отладка для первого сигнала
            if (signal.id === allSignals[0]?.id) {
                console.log('DEBUG Result:', {
                    pair: signal.pair,
                    calculated_result: signal.calculated_result,
                    calculatedResult: calculatedResult,
                    max_favorable_move: signal.max_favorable_move,
                    maxFavorable: maxFavorable,
                    max_adverse_move: signal.max_adverse_move,
                    maxAdverse: maxAdverse,
                    pnl_percent: signal.pnl_percent
                });
            }
            
            // Проверяем фактический результат (если ордер был исполнен и позиция закрыта)
            if (signal.demo_filled_at && signal.exit_price && signal.status === 'CLOSED') {
                // Позиция закрыта - показываем фактический результат
                if (calculatedResult > 0) {
                    resultDisplay = `+${calculatedResult.toFixed(2)}% ✅`;
                    resultClass = 'result-profit';
                } else if (calculatedResult < 0) {
                    resultDisplay = `${calculatedResult.toFixed(2)}% ❌`;
                    resultClass = 'result-loss';
                } else {
                    resultDisplay = '0.00%';
                    resultClass = 'result-neutral';
                }
            } else if (calculatedResult === 1.5 || Math.abs(calculatedResult - 1.5) < 0.01) {
                // Fallback для старых сигналов - прибыль
                resultDisplay = '+1.5% ✅';
                resultClass = 'result-profit';
            } else if (calculatedResult === -0.5 || Math.abs(calculatedResult - (-0.5)) < 0.01) {
                // Fallback для старых сигналов - убыток
                resultDisplay = '-0.5% ❌';
                resultClass = 'result-loss';
            } else {
                // Для сигналов в процессе показываем максимальное движение
                // Формат такой же как в столбце "Макс. движение": "+рост% / -падение%"
                if (maxFavorable !== 0 || maxAdverse !== 0 || pnlPercent !== 0) {
                    resultDisplay = `Макс: +${maxFavorable.toFixed(2)}% / -${maxAdverse.toFixed(2)}%`;
                } else {
                    resultDisplay = 'Анализ...';
                }
                if (status !== 'CLOSED') {
                    resultDisplay = `${resultDisplay}<br><small>${status}</small>`;
                }
            }
            if (status === 'CLOSED') {
                const reasonText = exitReason ? ` - ${exitReason.replace('_', ' ')}` : '';
                resultDisplay = `${resultDisplay}<br><small>${status}${reasonText}</small>`;
            }

            const tradeStatusHtml = getTradeStatusHtml(signal);

            return `
                <div class="table-row" data-signal-id="${signal.id}" onclick="openSignalChart(${signal.id})" title="Нажмите для просмотра графика">
                    <div><span style="color: var(--accent-primary); font-weight: bold;">#${signal.id || 'N/A'}</span></div>
                    <div class="cell-date"><span>${dateStr}</span><small>${timeStr}</small></div>
                    <div>${signal.pair || 'N/A'}</div>
                    <div><small>${timeframe}</small></div>
                    <div><span class="signal-type ${signalClass}">${signalType}</span></div>
                    <div>$${levelPrice.toFixed(4)}</div>
                    <div>$${entryPrice.toFixed(4)}</div>
                    <div>${stopLossDisplay}</div>
                    <div><small>H:${historicalTouches} / L:${liveTouches}</small></div>
                    <div><small>${scoreDisplay} / ${distanceDisplay}</small></div>
                    <div class="${trendClass}"><small>${trendDisplay}</small></div>
                    <div><small>${maxMoveDisplay}</small></div>
                    <div class="${resultClass}">${resultDisplay}</div>
                    <div>${tradeStatusHtml}</div>
                </div>
            `;
        }

        // Фильтрация по типу
        function filterByType(type) {
            document.querySelectorAll('.filter-btn').forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');
            
            if (type === 'all') {
                filteredSignals = [...allSignals];
            } else {
                filteredSignals = allSignals.filter(signal => 
                    (signal.signal_type || signal.type || '').toUpperCase() === type
                );
            }
            updateSignalsTable();
        }

        // Фильтрация по периоду
        function filterByPeriod(period) {
            const now = new Date();
            const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
            const weekAgo = new Date(today.getTime() - 7 * 24 * 60 * 60 * 1000);
            const monthAgo = new Date(today.getTime() - 30 * 24 * 60 * 60 * 1000);
            
            if (period === 'all') {
                filteredSignals = [...allSignals];
            } else {
                filteredSignals = allSignals.filter(signal => {
                    const signalDate = new Date(signal.timestamp || signal.created_at || Date.now());
                    
                    if (period === 'today') {
                        return signalDate >= today;
                    } else if (period === 'week') {
                        return signalDate >= weekAgo;
                    } else if (period === 'month') {
                        return signalDate >= monthAgo;
                    }
                    return true;
                });
            }
            updateSignalsTable();
        }

        // Поиск по парам
        function filterSignals() {
            const searchTerm = document.getElementById('search-input').value.toLowerCase();
            filteredSignals = allSignals.filter(signal => 
                (signal.pair || '').toLowerCase().includes(searchTerm)
            );
            updateSignalsTable();
        }

        // Обновление данных
        function refreshData() {
            if (!isLoading) {
                loadSignals(false); // false = не показывать полный индикатор загрузки
            }
        }

        // Автообновление каждые 30 секунд (только если страница активна)
        let autoRefreshInterval;
        
        function startAutoRefresh() {
            autoRefreshInterval = setInterval(() => {
                if (!document.hidden && !isLoading) {
                    loadSignals(false);
                }
            }, 30000);
        }
        
        function stopAutoRefresh() {
            if (autoRefreshInterval) {
                clearInterval(autoRefreshInterval);
            }
        }
        
        // Управление автообновлением при смене видимости страницы
        document.addEventListener('visibilitychange', function() {
            if (document.hidden) {
                stopAutoRefresh();
            } else {
                startAutoRefresh();
            }
        });
        
        // Запускаем автообновление
        startAutoRefresh();

        // Система переключения стилей
        function toggleDesignMenu() {
            const menu = document.getElementById('design-menu');
            const dropdown = document.querySelector('.design-dropdown');
            const isActive = menu.classList.contains('active');
            const isCosmic = document.body.classList.contains('theme-cosmic');
            
            if (!isActive && dropdown) {
                if (isCosmic) {
                    // Для космической темы перемещаем меню в конец body, чтобы избежать обрезания
                    const menuClone = menu.cloneNode(true);
                    menuClone.id = 'design-menu-cosmic';
                    menuClone.classList.add('cosmic-menu-portal');
                    document.body.appendChild(menuClone);
                    
                    // Вычисляем позицию
                    const rect = dropdown.getBoundingClientRect();
                    menuClone.style.position = 'fixed';
                    menuClone.style.top = (rect.bottom + 8) + 'px';
                    menuClone.style.right = (window.innerWidth - rect.right) + 'px';
                    menuClone.style.left = 'auto';
                    menuClone.style.bottom = 'auto';
                    menuClone.style.zIndex = '99999';
                    menuClone.style.display = 'block';
                    
                    // Обновляем обработчики событий для клонированного меню
                    menuClone.querySelectorAll('.design-option').forEach(option => {
                        option.onclick = function() {
                            const theme = this.dataset.theme;
                            switchTheme(theme);
                            // Удаляем клонированное меню
                            menuClone.remove();
                            menu.classList.remove('active');
                        };
                    });
                    
                    // Скрываем оригинальное меню
                    menu.style.display = 'none';
                } else {
                    // Для других тем сбрасываем стили
                    menu.style.position = '';
                    menu.style.top = '';
                    menu.style.right = '';
                    menu.style.left = '';
                    menu.style.bottom = '';
                    menu.style.display = '';
                }
            } else if (isActive && isCosmic) {
                // Закрываем меню в космической теме
                const cosmicMenu = document.getElementById('design-menu-cosmic');
                if (cosmicMenu) {
                    cosmicMenu.remove();
                }
                menu.style.display = '';
            }
            
            menu.classList.toggle('active');
        }

        // Закрытие меню при клике вне его
        document.addEventListener('click', function(event) {
            const dropdown = document.querySelector('.design-dropdown');
            const menu = document.getElementById('design-menu');
            const cosmicMenu = document.getElementById('design-menu-cosmic');
            const isCosmic = document.body.classList.contains('theme-cosmic');
            
            if (isCosmic && cosmicMenu && !cosmicMenu.contains(event.target) && !dropdown.contains(event.target)) {
                cosmicMenu.remove();
                menu.classList.remove('active');
                menu.style.display = '';
            } else if (!isCosmic && dropdown && !dropdown.contains(event.target)) {
                menu.classList.remove('active');
            }
        });

        // Обновление позиции меню при скролле для космической темы
        document.addEventListener('scroll', function() {
            const cosmicMenu = document.getElementById('design-menu-cosmic');
            const dropdown = document.querySelector('.design-dropdown');
            
            if (cosmicMenu && dropdown) {
                const rect = dropdown.getBoundingClientRect();
                cosmicMenu.style.top = (rect.bottom + 8) + 'px';
                cosmicMenu.style.right = (window.innerWidth - rect.right) + 'px';
            }
        }, true);

        function switchTheme(themeName) {
            // Сохраняем выбор
            localStorage.setItem('selectedTheme', themeName);
            
            // Применяем тему
            document.body.className = `theme-${themeName}`;
            
            // Обновляем активный пункт меню
            document.querySelectorAll('.design-option').forEach(option => {
                option.classList.remove('active');
                if (option.dataset.theme === themeName) {
                    option.classList.add('active');
                }
            });
            
            // Обновляем логотип в зависимости от темы
            updateLogo(themeName);
            
            // Закрываем меню
            document.getElementById('design-menu').classList.remove('active');
        }

        function updateLogo(themeName) {
            const logoSvg = document.querySelector('.logo svg');
            if (!logoSvg) return;

            const gradient = logoSvg.querySelector('#logoGradient');
            const stops = gradient ? gradient.querySelectorAll('stop') : null;
            
            if (themeName === 'classic') {
                // Классический: фиолетово-синий градиент
                logoSvg.innerHTML = `
                    <defs>
                        <linearGradient id="logoGradient" x1="0%" y1="0%" x2="100%" y2="100%">
                            <stop offset="0%" style="stop-color:#667eea;stop-opacity:1" />
                            <stop offset="50%" style="stop-color:#764ba2;stop-opacity:1" />
                            <stop offset="100%" style="stop-color:#ec4899;stop-opacity:1" />
                        </linearGradient>
                    </defs>
                    <circle cx="50" cy="50" r="30" fill="none" stroke="url(#logoGradient)" stroke-width="3"/>
                    <circle cx="50" cy="50" r="20" fill="none" stroke="url(#logoGradient)" stroke-width="2"/>
                    <circle cx="50" cy="50" r="8" fill="url(#logoGradient)"/>
                `;
            } else if (themeName === 'cosmic') {
                // Космический: фиолетовый + золотой
                logoSvg.innerHTML = `
                    <defs>
                        <linearGradient id="logoGradient" x1="0%" y1="0%" x2="100%" y2="100%">
                            <stop offset="0%" style="stop-color:#6c5ce7;stop-opacity:1" />
                            <stop offset="50%" style="stop-color:#a29bfe;stop-opacity:1" />
                            <stop offset="100%" style="stop-color:#fdcb6e;stop-opacity:1" />
                        </linearGradient>
                        <filter id="glow">
                            <feGaussianBlur stdDeviation="3" result="coloredBlur"/>
                            <feMerge>
                                <feMergeNode in="coloredBlur"/>
                                <feMergeNode in="SourceGraphic"/>
                            </feMerge>
                        </filter>
                    </defs>
                    <circle cx="50" cy="50" r="35" fill="none" stroke="url(#logoGradient)" stroke-width="2" filter="url(#glow)" opacity="0.6"/>
                    <polygon points="50,15 55,40 80,40 60,55 65,80 50,65 35,80 40,55 20,40 45,40" fill="url(#logoGradient)" filter="url(#glow)"/>
                    <circle cx="50" cy="50" r="5" fill="url(#logoGradient)" filter="url(#glow)"/>
                `;
            } else {
                // Cyberpunk: зеленый + розовый (текущий)
                logoSvg.innerHTML = `
                    <defs>
                        <linearGradient id="logoGradient" x1="0%" y1="0%" x2="100%" y2="100%">
                            <stop offset="0%" style="stop-color:#00ff41;stop-opacity:1" />
                            <stop offset="50%" style="stop-color:#00cc33;stop-opacity:1" />
                            <stop offset="100%" style="stop-color:#ff006e;stop-opacity:1" />
                        </linearGradient>
                        <filter id="glow">
                            <feGaussianBlur stdDeviation="4" result="coloredBlur"/>
                            <feMerge>
                                <feMergeNode in="coloredBlur"/>
                                <feMergeNode in="SourceGraphic"/>
                            </feMerge>
                        </filter>
                    </defs>
                    <rect x="20" y="20" width="60" height="60" fill="none" stroke="url(#logoGradient)" stroke-width="3" filter="url(#glow)"/>
                    <rect x="30" y="30" width="40" height="40" fill="none" stroke="url(#logoGradient)" stroke-width="2" filter="url(#glow)"/>
                    <line x1="20" y1="50" x2="30" y2="50" stroke="url(#logoGradient)" stroke-width="2" filter="url(#glow)"/>
                    <line x1="70" y1="50" x2="80" y2="50" stroke="url(#logoGradient)" stroke-width="2" filter="url(#glow)"/>
                    <line x1="50" y1="20" x2="50" y2="30" stroke="url(#logoGradient)" stroke-width="2" filter="url(#glow)"/>
                    <line x1="50" y1="70" x2="50" y2="80" stroke="url(#logoGradient)" stroke-width="2" filter="url(#glow)"/>
                    <circle cx="50" cy="50" r="5" fill="url(#logoGradient)" filter="url(#glow)"/>
                    <path d="M25 25 L35 35 M65 25 L75 35 M25 75 L35 65 M65 75 L75 65" stroke="url(#logoGradient)" stroke-width="1.5" opacity="0.7" filter="url(#glow)"/>
                `;
            }
        }

        // Загрузка сохраненной темы при загрузке страницы
        document.addEventListener('DOMContentLoaded', function() {
            const savedTheme = localStorage.getItem('selectedTheme') || 'cyberpunk';
            // Применяем тему без перезагрузки
            document.body.className = `theme-${savedTheme}`;
            updateLogo(savedTheme);
            
            // Обновляем активный пункт меню дизайна
            document.querySelectorAll('.design-option').forEach(option => {
                option.classList.remove('active');
                if (option.dataset.theme === savedTheme) {
                    option.classList.add('active');
                }
            });
            
            // Отмечаем активную навигацию
            const currentPath = window.location.pathname;
            if (currentPath.includes('/demo-trading')) {
                document.getElementById('nav-demo')?.classList.add('active');
            } else if (currentPath.includes('/signals')) {
                document.getElementById('nav-signals')?.classList.add('active');
            } else {
                document.getElementById('nav-dashboard')?.classList.add('active');
            }
        });

        // ============================================================================
        // ФУНКЦИИ ДЛЯ ОТОБРАЖЕНИЯ ГРАФИКА СИГНАЛА
        // ============================================================================

        // Проверка загрузки библиотеки графиков
        document.addEventListener('DOMContentLoaded', function() {
            if (typeof LightweightCharts === 'undefined') {
                console.warn('LightweightCharts library not loaded');
                setTimeout(() => {
                    if (typeof LightweightCharts === 'undefined') {
                        console.error('LightweightCharts library failed to load');
                    } else {
                        console.log('LightweightCharts library loaded successfully');
                    }
                }, 1000);
            } else {
                console.log('LightweightCharts library loaded successfully');
            }
        });

        function startSignalAutoRefresh() {
            if (!currentSignalId) return;
            if (signalAutoRefreshTimer) {
                clearTimeout(signalAutoRefreshTimer);
                signalAutoRefreshTimer = null;
            }

            // Базовый интервал
            let intervalMs = 20000;

            // Если есть актуальные данные по сигналу и цена близко к уровню — ускоряем обновление
            if (currentSignalData && currentSignalData.signal) {
                const s = currentSignalData.signal;
                const level = Number(s.level_price);
                const price = Number(s.current_price || s.entry_price || level);
                if (level && price) {
                    const devPct = Math.abs(price / level - 1) * 100;
                    if (devPct <= 1.0) {
                        intervalMs = 5000; // чаще обновляем, когда цена в радиусе 1%
                    }
                }
            }

            signalAutoRefreshTimer = setTimeout(async () => {
                if (!currentSignalId) return;
                
                // Сохраняем позицию скролла перед обновлением
                const modal = document.getElementById('signal-chart-modal');
                const modalContent = modal ? modal.querySelector('.modal-content') : null;
                const savedScrollTop = modalContent ? modalContent.scrollTop : 0;
                
                try {
                    const tf = document.getElementById('signal-timeframe-selector').value;
                    await Promise.all([
                        loadSignalChartData(currentSignalId, tf),
                        loadSignalLiveLog(currentSignalId),
                        loadElderScreensData(currentSignalId),
                    ]);
                } catch (e) {
                    console.warn('Ошибка автообновления графика/логов:', e);
                } finally {
                    // Восстанавливаем позицию скролла после обновления
                    if (modalContent && savedScrollTop > 0) {
                        // Используем requestAnimationFrame для плавного восстановления
                        requestAnimationFrame(() => {
                            modalContent.scrollTop = savedScrollTop;
                        });
                    }
                    
                    // Перезапускаем цикл, пока модалка открыта
                    if (document.getElementById('signal-chart-modal').classList.contains('active')) {
                        startSignalAutoRefresh();
                    }
                }
            }, intervalMs);
        }

        // Открытие модального окна с графиком сигнала
        async function openSignalChart(signalId) {
            if (typeof LightweightCharts === 'undefined') {
                alert('Библиотека графиков не загружена. Пожалуйста, обновите страницу.');
                return;
            }

            currentSignalId = signalId;

            // Показываем модальное окно
            const modal = document.getElementById('signal-chart-modal');
            const modalContent = modal.querySelector('.modal-content');
            modal.classList.add('active');
            
            // Прокручиваем модальное окно в начало при открытии
            if (modalContent) {
                modalContent.scrollTop = 0;
            }

            // Показываем индикатор загрузки
            const container = document.getElementById('signal-chart-container');
            container.innerHTML = `
                <div style="display: flex; align-items: center; justify-content: center; height: 100%; color: #a0aec0;">
                    <div style="text-align: center;">
                        <div class="spinner"></div>
                        <p style="margin-top: 1rem;">Загрузка данных графика...</p>
                    </div>
                </div>
            `;

            removeProgressIndicator();

            // Загружаем данные графика, лог действий и Elder's Triple Screen System
            await Promise.all([
                loadSignalChartData(signalId, document.getElementById('signal-timeframe-selector').value),
                loadSignalLiveLog(signalId),
                loadElderScreensData(signalId)
            ]);

            // Запускаем автообновление графика и логов
            startSignalAutoRefresh();
        }

        // Закрытие модального окна
        function closeSignalChart() {
            const modal = document.getElementById('signal-chart-modal');
            modal.classList.remove('active');

            if (signalAutoRefreshTimer) {
                clearTimeout(signalAutoRefreshTimer);
                signalAutoRefreshTimer = null;
            }

            // Отключаем ResizeObserver
            if (signalChartResizeObserver) {
                signalChartResizeObserver.disconnect();
                signalChartResizeObserver = null;
            }

            // Удаляем график
            if (currentSignalChart) {
                try {
                    currentSignalChart.remove();
                } catch (e) {
                    console.warn('Ошибка при удалении графика:', e);
                }
                currentSignalChart = null;
            }

            // Очищаем ссылки на серии
            currentCandlestickSeries = null;
            currentEntryLineSeries = null;
            currentExitLineSeries = null;

            removeProgressIndicator();

            currentSignalId = null;
            currentSignalData = null;
            const logContainer = document.getElementById('live-log-content');
            if (logContainer) {
                logContainer.innerHTML = '<div class="log-placeholder">История скрыта</div>';
            }
        }

        function removeProgressIndicator() {
            document.querySelectorAll('.progress-indicator').forEach(indicator => indicator.remove());
        }

        // Загрузка данных графика для сигнала
        async function loadSignalChartData(signalId, timeframe) {
            try {
                removeProgressIndicator();
                const timeout = 10000; // 10 секунд

                // Создаем AbortController для таймаута
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), timeout);

                try {
                    const response = await fetch(`${baseUrl}/api/signal-chart-data/${signalId}?timeframe=${timeframe}`, {
                        signal: controller.signal
                    });

                    clearTimeout(timeoutId);

                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }

                    const data = await response.json();

                    if (data.success) {
                        // Логируем данные для отладки
                        console.log('Данные получены от API:', {
                            signal: data.signal,
                            candlesCount: data.candles ? data.candles.length : 0,
                            firstCandle: data.candles && data.candles.length > 0 ? data.candles[0] : null,
                            lastCandle: data.candles && data.candles.length > 0 ? data.candles[data.candles.length - 1] : null
                        });
                        
                        currentSignalData = data;
                        createSignalChart(data);
                    } else {
                        throw new Error(data.error || 'Ошибка загрузки данных');
                    }
                } catch (error) {
                    clearTimeout(timeoutId);

                    if (error.name === 'AbortError') {
                        throw new Error('Превышено время ожидания ответа от сервера (10 секунд)');
                    } else if (error.name === 'TypeError' && error.message.includes('fetch')) {
                        throw new Error('Не удалось подключиться к серверу. Проверьте, что API Gateway запущен.');
                    }
                    throw error;
                }
            } catch (error) {
                console.error('Ошибка загрузки данных графика:', error);
                const container = document.getElementById('signal-chart-container');
                container.innerHTML = `
                    <div style="display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100%; padding: 2rem; text-align: center;">
                        <div style="color: #f56565; font-size: 1.5rem; margin-bottom: 1rem;">⚠️</div>
                        <h3 style="color: #f56565; margin-bottom: 1rem;">Ошибка загрузки данных</h3>
                        <p style="color: #a0aec0; margin-bottom: 1.5rem;">${error.message}</p>
                        <button onclick="loadSignalChartData(${signalId}, '${timeframe}')" 
                                style="background: #4299e1; color: white; border: none; padding: 0.75rem 1.5rem; border-radius: 0.5rem; cursor: pointer;">
                            🔄 Повторить попытку
                        </button>
                    </div>
                `;
            }
        }

        async function loadSignalLiveLog(signalId) {
            const container = document.getElementById('live-log-content');
            if (!container) return;
            if (!signalId) {
                container.innerHTML = '<div class="log-placeholder">Сигнал не выбран</div>';
                return;
            }
            container.innerHTML = '<div class="log-placeholder">Загрузка истории...</div>';
            try {
                const response = await fetch(`${baseUrl}/api/signals/${signalId}/live-log`);
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }
                const data = await response.json();
                renderSignalLiveLog(data.logs || []);
            } catch (error) {
                console.error('Ошибка загрузки live-логов:', error);
                container.innerHTML = `<div class="log-placeholder" style="color:#f56565;">Не удалось загрузить историю</div>`;
            }
        }

        function renderSignalLiveLog(logs) {
            const container = document.getElementById('live-log-content');
            if (!container) return;
            if (!logs || logs.length === 0) {
                container.innerHTML = '<div class="log-placeholder">Записей пока нет</div>';
                return;
            }
            const items = logs.slice().reverse().map(log => {
                const time = log.created_at ? formatMoscowTimeOnly(log.created_at) : '';
                const status = log.status ? `<span class="log-status">${log.status}</span>` : '';
                return `
                    <div class="live-log-item">
                        <div class="live-log-time">${time}</div>
                        <div class="live-log-message">${log.message || ''}${status ? `<br><small>${status}</small>` : ''}</div>
                    </div>
                `;
            }).join('');
            container.innerHTML = items;
        }

        // Загрузка данных Elder's Triple Screen System
        async function loadElderScreensData(signalId) {
            const container = document.getElementById('elder-screens-content');
            if (!container) return;
            if (!signalId) {
                container.innerHTML = '<div class="log-placeholder">Сигнал не выбран</div>';
                return;
            }
            container.innerHTML = '<div class="log-placeholder">Загрузка данных...</div>';
            try {
                const response = await fetch(`${baseUrl}/api/signal-chart-data/${signalId}?timeframe=15m`);
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }
                const data = await response.json();
                if (data.success && data.signal) {
                    renderElderScreens(data.signal);
                } else {
                    container.innerHTML = '<div class="log-placeholder">Данные недоступны</div>';
                }
            } catch (error) {
                console.error('Ошибка загрузки данных Elder\'s Triple Screen System:', error);
                container.innerHTML = '<div class="log-placeholder" style="color:#f56565;">Не удалось загрузить данные</div>';
            }
        }

        // Отображение данных Elder's Triple Screen System
        function renderElderScreens(signal) {
            const container = document.getElementById('elder-screens-content');
            if (!container) return;

            const metadata = signal.elder_screens_metadata || {};
            const screen1 = metadata.screen_1 || {};
            const screen2 = metadata.screen_2 || {};

            // Если нет данных, показываем сообщение
            if (!screen1 && !screen2 && !signal.elder_screens_metadata) {
                container.innerHTML = '<div class="log-placeholder">Данные проверок экранов недоступны (сигнал создан до внедрения системы трех экранов)</div>';
                return;
            }

            let html = '';

            // Экран 1: 4H тренд
            if (screen1) {
                // ИСПРАВЛЕНО: если данные не рассчитаны (passed === null/undefined), статус "НЕ ПРОВЕРЕНО"
                const screen1Passed = screen1.passed;
                const signal1Passed = signal.elder_screen_1_passed;
                const passed = (screen1Passed === true || signal1Passed === true) && 
                              (screen1Passed !== false && signal1Passed !== false);
                const notChecked = (screen1Passed === null || screen1Passed === undefined) && 
                                  (signal1Passed === null || signal1Passed === undefined);
                const blockedReason = signal.elder_screen_1_blocked_reason || screen1.blocked_reason || '';
                const passedReason = screen1.passed_reason || '';  // Явное сообщение о прохождении (для SIDEWAYS)
                const checks = screen1.checks || {};
                // Используем данные из screen1 напрямую, если есть, иначе из checks
                const btcTrend = screen1.btc_trend || checks.btc_trend || null;
                const btcTrendData = screen1.btc_trend_data || checks.btc_trend_data || null;
                const pairTrend = screen1.pair_trend_data || checks.pair_trend || {};
                
                // Форматируем BTC тренд
                let btcTrendDisplay = 'N/A';
                let btcTrendDetails = '';
                if (btcTrend) {
                    btcTrendDisplay = btcTrend;
                    // Добавляем детали для SIDEWAYS
                    if (btcTrend === 'SIDEWAYS' && btcTrendData) {
                        const adx = btcTrendData.adx;
                        const ema20 = btcTrendData.ema20;
                        const ema50 = btcTrendData.ema50;
                        if (adx !== undefined && adx !== null) {
                            btcTrendDetails = ` (ADX: ${adx.toFixed(2)})`;
                        }
                        if (ema20 !== undefined && ema50 !== undefined) {
                            btcTrendDetails += ` EMA20: ${ema20.toFixed(2)}, EMA50: ${ema50.toFixed(2)}`;
                        }
                    }
                } else if (btcTrend === null || btcTrend === undefined) {
                    btcTrendDisplay = 'Не рассчитан';
                }
                
                // Форматируем тренд пары
                let pairTrendDisplay = 'N/A';
                let pairTrendDetails = '';
                if (typeof pairTrend === 'object' && pairTrend !== null) {
                    pairTrendDisplay = pairTrend.trend || 'N/A';
                    if (pairTrend.ema20 && pairTrend.ema50) {
                        pairTrendDetails = ` (EMA20: ${pairTrend.ema20.toFixed(4)}, EMA50: ${pairTrend.ema50.toFixed(4)})`;
                    }
                    if (pairTrend.adx !== undefined && pairTrend.adx !== null) {
                        pairTrendDetails += ` ADX: ${pairTrend.adx.toFixed(2)}`;
                    }
                } else if (pairTrend) {
                    pairTrendDisplay = pairTrend;
                } else {
                    pairTrendDisplay = 'Не рассчитан';
                }

                html += `
                    <div class="elder-screen-card ${passed ? '' : (notChecked ? 'not-checked' : 'blocked')}">
                        <div class="elder-screen-header">
                            <div class="elder-screen-title">Экран 1: 4H Тренд</div>
                            <div class="elder-screen-status ${passed ? 'passed' : (notChecked ? 'not-checked' : 'blocked')}">
                                ${passed ? '✅ ПРОЙДЕН' : (notChecked ? '⏳ НЕ ПРОВЕРЕНО' : '❌ ЗАБЛОКИРОВАН')}
                            </div>
                        </div>
                        <div class="elder-screen-details">
                            <div class="elder-screen-details-item ${passed ? '' : 'blocked'}">
                                <strong>BTC тренд (4H):</strong> ${btcTrendDisplay}${btcTrendDetails}
                                ${btcTrend ? ` <small style="color: var(--text-muted);">(определяет общее направление рынка)</small>` : ''}
                            </div>
                            <div class="elder-screen-details-item ${passed ? '' : 'blocked'}">
                                <strong>Тренд пары (4H):</strong> ${pairTrendDisplay}${pairTrendDetails}
                                ${pairTrendDisplay !== 'N/A' && pairTrendDisplay !== 'Не рассчитан' ? ` <small style="color: var(--text-muted);">(EMA20 vs EMA50, ADX)</small>` : ''}
                            </div>
                            ${passedReason ? `
                                <div class="elder-screen-details-item" style="color: #48bb78; margin-top: 0.5rem; padding-top: 0.5rem; border-top: 1px solid rgba(72, 187, 120, 0.3);">
                                    <strong>✅ Проверка выполнена:</strong> ${passedReason}
                                </div>
                            ` : ''}
                            ${blockedReason ? `
                                <div class="elder-screen-details-item blocked">
                                    <strong>Причина блокировки:</strong> ${blockedReason}
                                </div>
                            ` : ''}
                        </div>
                    </div>
                `;
            }

            // Экран 2: 1H анализ
            if (screen2) {
                // ИСПРАВЛЕНО: если данные не рассчитаны (passed === null/undefined), статус "НЕ ПРОВЕРЕНО"
                const screen2Passed = screen2.passed;
                const signal2Passed = signal.elder_screen_2_passed;
                const passed = (screen2Passed === true || signal2Passed === true) && 
                              (screen2Passed !== false && signal2Passed !== false);
                const notChecked = (screen2Passed === null || screen2Passed === undefined) && 
                                  (signal2Passed === null || signal2Passed === undefined);
                const blockedReason = signal.elder_screen_2_blocked_reason || screen2.blocked_reason || '';
                const checks = screen2.checks || {};
                const priceApproach = checks.price_approach || {};
                const oscillators = checks.oscillators || {};
                const rsi = checks.rsi || {};
                const macd = checks.macd || {};

                html += `
                    <div class="elder-screen-card ${passed ? '' : (notChecked ? 'not-checked' : 'blocked')}">
                        <div class="elder-screen-header">
                            <div class="elder-screen-title">Экран 2: 1H Анализ</div>
                            <div class="elder-screen-status ${passed ? 'passed' : (notChecked ? 'not-checked' : 'blocked')}">
                                ${passed ? '✅ ПРОЙДЕН' : (notChecked ? '⏳ НЕ ПРОВЕРЕНО' : '❌ ЗАБЛОКИРОВАН')}
                            </div>
                        </div>
                        <div class="elder-screen-details">
                            <div style="margin-bottom: 0.5rem; padding-bottom: 0.5rem; border-bottom: 1px solid rgba(255, 255, 255, 0.1);">
                                <strong style="color: var(--text-primary);">Проверки:</strong>
                            </div>
                            
                            ${priceApproach.direction ? `
                                <div class="elder-screen-details-item ${priceApproach.valid !== false ? '' : 'blocked'}">
                                    <strong>1. Направление подхода цены:</strong> ${priceApproach.direction}
                                    ${priceApproach.valid !== false ? ' ✅' : ' ❌'}
                                    <br><small style="color: var(--text-muted); margin-left: 1rem;">
                                        ${priceApproach.valid !== false 
                                            ? 'Цена корректно приближается к уровню (не пробой)' 
                                            : priceApproach.reason || 'Направление подхода некорректно'}
                                    </small>
                                </div>
                            ` : `
                                <div class="elder-screen-details-item">
                                    <strong>1. Направление подхода:</strong> <span style="color: var(--text-muted);">Не проверено</span>
                                </div>
                            `}
                            
                            ${oscillators.rsi !== undefined && oscillators.rsi !== null ? `
                                <div class="elder-screen-details-item ${rsi.blocked ? 'blocked' : ''}">
                                    <strong>2. RSI (14 периодов):</strong> ${oscillators.rsi.toFixed(2)}
                                    ${rsi.blocked ? ' ❌' : rsi.warning ? ' ⚠️' : ' ✅'}
                                    <br><small style="color: var(--text-muted); margin-left: 1rem;">
                                        ${signal.signal_type === 'LONG' 
                                            ? (rsi.blocked 
                                                ? `RSI ${oscillators.rsi.toFixed(2)} > 75 (перекуплен, блокировка LONG)`
                                                : rsi.warning 
                                                    ? `RSI ${oscillators.rsi.toFixed(2)} в зоне 70-75 (предупреждение, но разрешено)`
                                                    : `RSI ${oscillators.rsi.toFixed(2)} < 70 (OK для LONG)`)
                                            : (rsi.blocked 
                                                ? `RSI ${oscillators.rsi.toFixed(2)} < 25 (перепродан, блокировка SHORT)`
                                                : rsi.warning 
                                                    ? `RSI ${oscillators.rsi.toFixed(2)} в зоне 25-30 (предупреждение, но разрешено)`
                                                    : `RSI ${oscillators.rsi.toFixed(2)} > 30 (OK для SHORT)`)
                                        }
                                    </small>
                                </div>
                            ` : `
                                <div class="elder-screen-details-item">
                                    <strong>2. RSI:</strong> <span style="color: var(--text-muted);">Не рассчитан (недостаточно данных)</span>
                                </div>
                            `}
                            
                            ${oscillators.macd !== undefined && oscillators.macd !== null && oscillators.macd_signal !== undefined && oscillators.macd_signal !== null ? `
                                <div class="elder-screen-details-item ${macd.blocked ? 'blocked' : ''}">
                                    <strong>3. MACD:</strong> ${oscillators.macd.toFixed(4)} | Signal: ${oscillators.macd_signal.toFixed(4)}
                                    ${macd.blocked ? ' ❌' : ' ✅'}
                                    <br><small style="color: var(--text-muted); margin-left: 1rem;">
                                        ${signal.signal_type === 'LONG' 
                                            ? (macd.blocked 
                                                ? `MACD ${oscillators.macd.toFixed(4)} < Signal ${oscillators.macd_signal.toFixed(4)} (медвежий сигнал, блокировка LONG)`
                                                : `MACD ${oscillators.macd.toFixed(4)} > Signal ${oscillators.macd_signal.toFixed(4)} (бычий сигнал, OK для LONG)`)
                                            : (macd.blocked 
                                                ? `MACD ${oscillators.macd.toFixed(4)} > Signal ${oscillators.macd_signal.toFixed(4)} (бычий сигнал, блокировка SHORT)`
                                                : `MACD ${oscillators.macd.toFixed(4)} < Signal ${oscillators.macd_signal.toFixed(4)} (медвежий сигнал, OK для SHORT)`)
                                        }
                                        ${oscillators.macd_histogram !== undefined && oscillators.macd_histogram !== null 
                                            ? ` | Histogram: ${oscillators.macd_histogram.toFixed(4)}`
                                            : ''}
                                    </small>
                                </div>
                            ` : `
                                <div class="elder-screen-details-item">
                                    <strong>3. MACD:</strong> <span style="color: var(--text-muted);">Не рассчитан (недостаточно данных)</span>
                                </div>
                            `}
                            
                            ${blockedReason ? `
                                <div class="elder-screen-details-item blocked" style="margin-top: 0.5rem; padding-top: 0.5rem; border-top: 1px solid rgba(255, 0, 110, 0.3);">
                                    <strong>Итоговая причина блокировки:</strong> ${blockedReason}
                                </div>
                            ` : passed ? `
                                <div class="elder-screen-details-item" style="margin-top: 0.5rem; padding-top: 0.5rem; border-top: 1px solid rgba(0, 255, 65, 0.3);">
                                    <strong>Итог:</strong> <span style="color: var(--accent-success);">Все проверки пройдены ✅</span>
                                </div>
                            ` : ''}
                        </div>
                    </div>
                `;
            }

            // Экран 3: 15M вход (используется для определения точки входа)
            // Экран 3 реализован через проверку касания уровня на 15M таймфрейме
            // Если уровень касается и все условия выполнены, сигнал генерируется
            html += `
                <div class="elder-screen-card">
                    <div class="elder-screen-header">
                        <div class="elder-screen-title">Экран 3: 15M Вход</div>
                        <div class="elder-screen-status passed">
                            ✅ АКТИВЕН
                        </div>
                    </div>
                    <div class="elder-screen-details">
                        <div class="elder-screen-details-item">
                            <strong>Механизм входа:</strong> Сигнал генерируется при касании уровня на 15M таймфрейме
                        </div>
                        <div class="elder-screen-details-item">
                            <strong>Условия:</strong> Цена должна коснуться уровня (в пределах 0.1% толерантности)
                        </div>
                        <div class="elder-screen-details-item">
                            <strong>Тип ордера:</strong> Лимитный ордер на уровне (или рыночный, если отклонение ≤ 0.15%)
                        </div>
                    </div>
                </div>
            `;

            container.innerHTML = html;
        }

        // Создание графика для сигнала
        function createSignalChart(data) {
            const container = document.getElementById('signal-chart-container');
            
            // КРИТИЧЕСКИ ВАЖНО: если график уже существует И это тот же сигнал, обновляем данные без пересоздания
            // Если сигнал изменился, пересоздаем график
            const isUpdate = currentSignalChart !== null && 
                            currentCandlestickSeries !== null && 
                            currentSignalId === data.signal.id;
            
            // Сохраняем видимый диапазон времени перед обновлением (если график существует)
            let savedVisibleRange = null;
            if (isUpdate && currentSignalChart) {
                try {
                    savedVisibleRange = currentSignalChart.timeScale().getVisibleRange();
                    console.log('💾 Сохранен видимый диапазон:', savedVisibleRange);
                } catch (e) {
                    console.warn('Не удалось сохранить видимый диапазон:', e);
                }
            }
            
            // Очищаем контейнер только при первом создании
            if (!isUpdate) {
                container.innerHTML = '';
            }

            const signal = data.signal;
            const candles = data.candles;

            console.log('createSignalChart вызвана с данными:', {
                signal: signal ? 'present' : 'missing',
                candlesCount: candles ? candles.length : 0,
                candlesType: Array.isArray(candles) ? 'array' : typeof candles
            });

            if (!candles || !Array.isArray(candles) || candles.length === 0) {
                const errorMsg = !candles ? 'Данные свечей отсутствуют' : 
                                !Array.isArray(candles) ? `Данные свечей не являются массивом (тип: ${typeof candles})` :
                                'Массив свечей пуст';
                console.error('Ошибка: нет данных для графика:', errorMsg);
                container.innerHTML = `<div style="color: #f56565; padding: 2rem; text-align: center;">
                    <h3>Ошибка загрузки данных</h3>
                    <p>${errorMsg}</p>
                </div>`;
                return;
            }
            
            console.log(`Обрабатываем ${candles.length} свечей`);

            // Обновляем заголовок и информацию о сигнале
            document.getElementById('signal-modal-title').textContent = `${signal.pair} - Сигнал ${signal.signal_type}`;
            
            const signalInfo = document.getElementById('signal-info');
            const entryDate = signal.entry_timestamp ? formatMoscowTime(signal.entry_timestamp) : 'N/A';
            const exitDate = signal.exit_timestamp ? formatMoscowTime(signal.exit_timestamp) : 'В процессе';
            
            // Рассчитываем фактический результат ТОЛЬКО если ордер был отправлен на биржу (есть demo_order_id)
            // Если нет demo_order_id, значит ордер не был отправлен, и результата быть не должно
            let resultText = 'В процессе';
            if (signal.demo_order_id && signal.entry_price && signal.exit_price) {
                // Ордер был отправлен и исполнен - рассчитываем результат
                const entryPrice = Number(signal.entry_price);
                const exitPrice = Number(signal.exit_price);
                if (entryPrice > 0 && exitPrice > 0) {
                    let actualResultPct = 0;
                    if (signal.signal_type === 'LONG') {
                        actualResultPct = ((exitPrice - entryPrice) / entryPrice) * 100.0;
                    } else { // SHORT
                        actualResultPct = ((entryPrice - exitPrice) / entryPrice) * 100.0;
                    }
                    const color = actualResultPct > 0 ? '#48bb78' : '#f56565';
                    const icon = actualResultPct > 0 ? '✅' : '❌';
                    resultText = `<span style="color: ${color};">${actualResultPct >= 0 ? '+' : ''}${actualResultPct.toFixed(2)}% ${icon}</span>`;
                    console.log(`📊 Фактический результат в модальном окне для сигнала ${signal.id}: ${actualResultPct.toFixed(2)}% (entry: ${entryPrice}, exit: ${exitPrice}, type: ${signal.signal_type})`);
                }
            } else if (!signal.demo_order_id && (signal.entry_price || signal.exit_price)) {
                // Ордер не был отправлен, но есть entry_price/exit_price - это теоретический расчет, не показываем
                resultText = 'Ордер не был отправлен';
                console.log(`Сигнал ${signal.id}: нет demo_order_id, результат не показывается`);
            } else if (signal.result_fixed !== null) {
                // Fallback для старых сигналов без live-торговли
                resultText = signal.result_fixed === 1.5 
                    ? '<span style="color: #48bb78;">+1.5% ✅</span>' 
                    : '<span style="color: #f56565;">-0.5% ❌</span>';
            }
            const status = (signal.status || 'ACTIVE').toUpperCase();
            const exitReason = signal.exit_reason ? signal.exit_reason.replace('_', ' ') : null;
            const timeframe = (signal.timeframe || signal.metadata?.timeframe || '15m').toUpperCase();
            const historicalTouches = signal.historical_touches ?? signal.metadata?.historical_touches ?? signal.test_count ?? 0;
            const liveTouches = signal.live_test_count ?? signal.metadata?.live_test_count ?? 0;
            const levelScore = signal.level_score ?? signal.metadata?.level_score ?? signal.metadata?.score ?? null;
            const distancePercent = signal.distance_percent ?? signal.metadata?.distance_percent ?? null;
            const scoreDisplay = levelScore !== null && levelScore !== undefined ? Number(levelScore).toFixed(1) : '—';
            const distanceDisplay = distancePercent !== null && distancePercent !== undefined ? `${Number(distancePercent).toFixed(2)}%` : '—';
            
            // Безопасное форматирование цены
            const formatPrice = (price) => {
                if (price == null || price === undefined) return 'N/A';
                const priceNum = Number(price);
                if (isNaN(priceNum) || !isFinite(priceNum)) return 'N/A';
                return `$${priceNum.toFixed(4)}`;
            };
            
            signalInfo.innerHTML = `
                <div class="signal-info-item">
                    <strong>Тип:</strong> ${signal.signal_type || 'N/A'}
                </div>
                <div class="signal-info-item">
                    <strong>Статус:</strong> ${status}${exitReason ? ` (${exitReason})` : ''}
                </div>
                <div class="signal-info-item">
                    <strong>ТФ уровня:</strong> ${timeframe}
                </div>
                <div class="signal-info-item">
                    <strong>Вход:</strong> ${formatPrice(signal.entry_price)}
                </div>
                <div class="signal-info-item">
                    <strong>Время входа:</strong> ${entryDate}
                </div>
                ${signal.exit_price != null ? `
                    <div class="signal-info-item">
                        <strong>Выход:</strong> ${formatPrice(signal.exit_price)}
                    </div>
                    <div class="signal-info-item">
                        <strong>Время выхода:</strong> ${exitDate}
                    </div>
                    <div class="signal-info-item">
                        <strong>Результат:</strong> ${resultText}
                    </div>
                ` : `
                    <div class="signal-info-item">
                        <strong>Результат:</strong> ${resultText}
                    </div>
                `}
                <div class="signal-info-item">
                    <strong>Касания:</strong> Hist ${historicalTouches} / Live ${liveTouches}
                </div>
                <div class="signal-info-item">
                    <strong>Score / Dist:</strong> ${scoreDisplay} / ${distanceDisplay}
                </div>
            `;

            try {
                // Проверяем, что контейнер существует и имеет размер
                if (!container || container.clientWidth === 0 || container.clientHeight === 0) {
                    console.warn('Контейнер графика не готов, устанавливаем минимальные размеры');
                    container.style.minWidth = '800px';
                    container.style.minHeight = '600px';
                }
                
                const chartWidth = container.clientWidth || 800;
                const chartHeight = container.clientHeight || 600;
                
                // Если график уже существует, обновляем его размеры и данные
                if (isUpdate && currentSignalChart) {
                    console.log('🔄 Обновление существующего графика (без пересоздания)');
                    currentSignalChart.applyOptions({ width: chartWidth, height: chartHeight });
                } else {
                    // Создаем новый график только если его нет
                    console.log('🆕 Создание нового графика');
                    currentSignalChart = LightweightCharts.createChart(container, {
                    width: chartWidth,
                    height: chartHeight,
                    layout: {
                        background: { color: '#1a202c' },
                        textColor: '#e2e8f0',
                    },
                    grid: {
                        vertLines: { color: '#2d3748' },
                        horzLines: { color: '#2d3748' },
                    },
                    crosshair: {
                        mode: LightweightCharts.CrosshairMode.Normal,
                    },
                    rightPriceScale: {
                        borderColor: '#2d3748',
                    },
                    timeScale: {
                        borderColor: '#2d3748',
                        timeVisible: true,
                        secondsVisible: false,
                        // Настройка форматирования времени для московского часового пояса (компактный формат)
                        tickMarkFormatter: (time, tickMarkType, locale) => {
                            const date = new Date(time * 1000);
                            
                            // Используем Intl для корректной конвертации в московское время
                            const formatter = new Intl.DateTimeFormat('ru-RU', {
                                timeZone: 'Europe/Moscow',
                                hour: '2-digit',
                                minute: '2-digit',
                                hour12: false
                            });
                            
                            const dateFormatter = new Intl.DateTimeFormat('ru-RU', {
                                timeZone: 'Europe/Moscow',
                                month: '2-digit',
                                day: '2-digit'
                            });
                            
                            // Адаптивный формат в зависимости от типа метки
                            // 0 = день, 1 = месяц, 2 = год, 3 = час, 4 = минута
                            if (tickMarkType === 0) {
                                // Для дней: DD.MM HH:MM (компактно)
                                return dateFormatter.format(date) + ' ' + formatter.format(date);
                            } else if (tickMarkType === 1) {
                                // Для месяцев: DD.MM (только дата)
                                return dateFormatter.format(date);
                            } else {
                                // Для часов/минут: HH:MM (только время)
                                return formatter.format(date);
                            }
                        },
                    },
                    });
                    
                    if (!currentSignalChart) {
                        throw new Error('Не удалось создать график');
                    }
                }
                
                if (isUpdate) {
                    console.log('✅ График обновлен, размеры:', chartWidth, 'x', chartHeight);
                } else {
                    console.log('✅ График создан успешно, размеры:', chartWidth, 'x', chartHeight);
                }

                // Добавляем или используем существующую серию свечей
                let candlestickSeries;
                if (isUpdate && currentCandlestickSeries) {
                    // Используем существующую серию
                    candlestickSeries = currentCandlestickSeries;
                    console.log('🔄 Используем существующую серию свечей');
                } else {
                    // Создаем новую серию
                    candlestickSeries = currentSignalChart.addCandlestickSeries({
                        upColor: '#48bb78',
                        downColor: '#f56565',
                        borderDownColor: '#f56565',
                        borderUpColor: '#48bb78',
                        wickDownColor: '#f56565',
                        wickUpColor: '#48bb78',
                    });
                    currentCandlestickSeries = candlestickSeries; // Сохраняем ссылку
                    console.log('🆕 Создана новая серия свечей');
                }

                // Конвертируем данные для Lightweight Charts
                // Валидируем и фильтруем данные
                const chartData = [];
                for (const candle of candles) {
                    // Проверяем формат timestamp
                    let timestamp = candle.timestamp;
                    if (typeof timestamp === 'string') {
                        // Если timestamp строка, конвертируем в число
                        timestamp = new Date(timestamp).getTime();
                    } else if (typeof timestamp !== 'number') {
                        console.warn('Неизвестный формат timestamp:', timestamp, typeof timestamp);
                        continue;
                    }
                    
                    // Конвертируем timestamp в секунды (LightweightCharts требует Unix timestamp в секундах)
                    const time = Math.floor(timestamp / 1000);
                    
                    // Проверяем, что все значения присутствуют и являются числами
                    // Используем Number() вместо parseFloat для более строгой проверки
                    const open = Number(candle.open);
                    const high = Number(candle.high);
                    const low = Number(candle.low);
                    const close = Number(candle.close);
                    
                    // Пропускаем свечи с null/undefined значениями
                    if (candle.open === null || candle.open === undefined ||
                        candle.high === null || candle.high === undefined ||
                        candle.low === null || candle.low === undefined ||
                        candle.close === null || candle.close === undefined) {
                        console.warn('Пропущена свеча с null значениями:', candle);
                        continue;
                    }
                    
                    // Пропускаем свечи с невалидными данными (NaN или Infinity)
                    if (isNaN(time) || !isFinite(time) || 
                        isNaN(open) || !isFinite(open) || 
                        isNaN(high) || !isFinite(high) || 
                        isNaN(low) || !isFinite(low) || 
                        isNaN(close) || !isFinite(close)) {
                        console.warn('Пропущена свеча с невалидными данными (NaN/Infinity):', {
                            time, open, high, low, close,
                            original: candle
                        });
                        continue;
                    }
                    
                    // Проверяем, что значения логически корректны
                    // high >= low, high >= open, high >= close, low <= open, low <= close
                    if (high < low || high < open || high < close || 
                        low > open || low > close || 
                        open <= 0 || close <= 0 || high <= 0 || low <= 0) {
                        console.warn('Пропущена свеча с некорректными значениями (логическая ошибка):', {
                            open, high, low, close,
                            original: candle
                        });
                        continue;
                    }
                    
                    // Убеждаемся, что все значения действительно числа (не null, не undefined)
                    if (typeof time === 'number' && 
                        typeof open === 'number' && 
                        typeof high === 'number' && 
                        typeof low === 'number' && 
                        typeof close === 'number' &&
                        isFinite(time) && isFinite(open) && isFinite(high) && isFinite(low) && isFinite(close)) {
                        chartData.push({
                            time: time,
                            open: open,
                            high: high,
                            low: low,
                            close: close,
                        });
                    } else {
                        console.warn('Пропущена свеча: значения не являются числами', {
                            time, open, high, low, close,
                            types: {
                                time: typeof time,
                                open: typeof open,
                                high: typeof high,
                                low: typeof low,
                                close: typeof close
                            }
                        });
                    }
                }
                
                if (chartData.length === 0) {
                    throw new Error('Нет валидных данных для отображения на графике');
                }
                
                // Сортируем данные по времени (LightweightCharts требует сортировку)
                chartData.sort((a, b) => a.time - b.time);
                
                // Удаляем дубликаты по времени (оставляем последнюю)
                const uniqueChartData = [];
                const timeMap = new Map();
                for (const candle of chartData) {
                    timeMap.set(candle.time, candle);
                }
                uniqueChartData.push(...Array.from(timeMap.values()));
                uniqueChartData.sort((a, b) => a.time - b.time);
                
                console.log(`Загружено ${uniqueChartData.length} свечей для графика (было ${chartData.length}, удалено ${chartData.length - uniqueChartData.length} дубликатов)`);
                console.log('Первая свеча:', uniqueChartData[0]);
                console.log('Последняя свеча:', uniqueChartData[uniqueChartData.length - 1]);
                
                // Финальная проверка: убеждаемся, что нет null/undefined значений
                const finalData = uniqueChartData.filter(candle => {
                    const isValid = candle.time != null && 
                                   candle.open != null && 
                                   candle.high != null && 
                                   candle.low != null && 
                                   candle.close != null &&
                                   typeof candle.time === 'number' &&
                                   typeof candle.open === 'number' &&
                                   typeof candle.high === 'number' &&
                                   typeof candle.low === 'number' &&
                                   typeof candle.close === 'number';
                    if (!isValid) {
                        console.warn('Пропущена свеча с null/undefined значениями в финальной проверке:', candle);
                    }
                    return isValid;
                });
                
                if (finalData.length === 0) {
                    throw new Error('Нет валидных данных после финальной проверки');
                }

                console.log(`Финальное количество свечей: ${finalData.length}`);
                
                // Финальная проверка данных перед передачей в библиотеку
                // LightweightCharts требует, чтобы данные были отсортированы и не содержали null
                const validatedFinalData = finalData.filter((candle, index) => {
                    const isValid = candle != null &&
                                   typeof candle === 'object' &&
                                   candle.time != null &&
                                   candle.open != null &&
                                   candle.high != null &&
                                   candle.low != null &&
                                   candle.close != null &&
                                   typeof candle.time === 'number' &&
                                   typeof candle.open === 'number' &&
                                   typeof candle.high === 'number' &&
                                   typeof candle.low === 'number' &&
                                   typeof candle.close === 'number' &&
                                   !isNaN(candle.time) && !isNaN(candle.open) && 
                                   !isNaN(candle.high) && !isNaN(candle.low) && 
                                   !isNaN(candle.close) &&
                                   isFinite(candle.time) && isFinite(candle.open) &&
                                   isFinite(candle.high) && isFinite(candle.low) &&
                                   isFinite(candle.close) &&
                                   candle.time > 0 && candle.open > 0 &&
                                   candle.high > 0 && candle.low > 0 &&
                                   candle.close > 0 &&
                                   candle.high >= candle.low;
                    
                    if (!isValid && index < 5) {
                        console.warn(`Пропущена невалидная свеча #${index}:`, candle);
                    }
                    return isValid;
                });
                
                if (validatedFinalData.length === 0) {
                    throw new Error('Нет валидных данных после финальной фильтрации');
                }
                
                // Убеждаемся, что данные отсортированы по времени
                validatedFinalData.sort((a, b) => a.time - b.time);
                
                console.log(`Отправляем ${validatedFinalData.length} валидных свечей в LightweightCharts`);
                console.log('Первая свеча (валидированная):', validatedFinalData[0]);
                console.log('Последняя свеча (валидированная):', validatedFinalData[validatedFinalData.length - 1]);
                
                // Устанавливаем данные в график СНАЧАЛА
                // Это важно - данные должны быть установлены до создания маркеров и линий
                if (isUpdate) {
                    // При обновлении используем setData (полная замена данных)
                    // LightweightCharts автоматически обновит только изменившиеся свечи
                    candlestickSeries.setData(validatedFinalData);
                    console.log('✅ Данные свечей обновлены (без пересоздания графика)');
                    
                    // Восстанавливаем видимый диапазон после обновления данных
                    if (savedVisibleRange && currentSignalChart) {
                        try {
                            // Небольшая задержка для завершения обновления данных
                            setTimeout(() => {
                                try {
                                    currentSignalChart.timeScale().setVisibleRange(savedVisibleRange);
                                    console.log('✅ Восстановлен видимый диапазон:', savedVisibleRange);
                                } catch (e) {
                                    console.warn('Не удалось восстановить видимый диапазон:', e);
                                }
                            }, 50);
                        } catch (e) {
                            console.warn('Ошибка при восстановлении видимого диапазона:', e);
                        }
                    }
                } else {
                    // При первом создании просто устанавливаем данные
                    candlestickSeries.setData(validatedFinalData);
                    console.log('✅ Данные свечей успешно установлены в график');
                }

                // Добавляем индикатор прогресса движения цены относительно точки входа
                const lastCandle = validatedFinalData[validatedFinalData.length - 1];
                const parseNumber = (value) => {
                    const num = Number(value);
                    return isNaN(num) || !isFinite(num) ? null : num;
                };

                const entryPrice = parseNumber(signal.entry_price ?? signal.level_price);
                const backendCurrentPrice = parseNumber(signal.current_price);
                const backendMovePct = parseNumber(signal.pnl_percent);
                const backendMoveAbs = parseNumber(signal.pnl);
                const fallbackCurrentPrice = lastCandle ? parseNumber(lastCandle.close) : null;

                const currentPrice = backendCurrentPrice ?? fallbackCurrentPrice;
                let movePct = backendMovePct;
                let moveAbs = backendMoveAbs;

                if ((movePct === null || moveAbs === null) && entryPrice && currentPrice) {
                    const delta = signal.signal_type === 'LONG'
                        ? currentPrice - entryPrice
                        : entryPrice - currentPrice;
                    if (movePct === null) {
                        movePct = (delta / entryPrice) * 100;
                    }
                    if (moveAbs === null) {
                        moveAbs = delta;
                    }
                }

                if (entryPrice && movePct !== null && moveAbs !== null) {
                    const tpThreshold = 1.5;
                    const slThreshold = -0.5;
                    const clampedProgress = Math.min(tpThreshold, Math.max(slThreshold, movePct));
                    const percentWidth = ((clampedProgress - slThreshold) / (tpThreshold - slThreshold)) * 100;

                    const tpRemaining = Math.max(0, tpThreshold - movePct);
                    const slBuffer = Math.max(0, movePct - slThreshold);

                    const progressMarkup = `
                        <div class="progress-indicator">
                            <div class="progress-header">
                                <div><strong>Прогресс (данные сервера):</strong> ${movePct >= 0 ? '+' : ''}${movePct.toFixed(2)}% (${moveAbs >= 0 ? '+' : ''}${moveAbs.toFixed(4)})</div>
                                <div><strong>До TP:</strong> ${tpRemaining.toFixed(2)}%</div>
                                <div><strong>Запас до SL:</strong> ${slBuffer.toFixed(2)}%</div>
                            </div>
                            <div class="progress-bar-wrapper">
                                <div class="progress-bar" style="width: ${percentWidth}%;"></div>
                            </div>
                            <div class="progress-markers">
                                <span>-0.5% (SL)</span>
                                <span>0%</span>
                                <span>+1.5% (TP)</span>
                            </div>
                            <small style="color: var(--text-muted); font-size: 0.75rem;">* Значения совпадают с расчетом P&L, выполняемым сервером.</small>
                        </div>
                    `;

                    const chartControls = document.querySelector('.chart-controls');
                    if (chartControls) {
                        chartControls.insertAdjacentHTML('afterend', progressMarkup);
                    }
                }

                // ТЕПЕРЬ добавляем маркеры и линии (после установки данных свечей)
                const markers = [];

                // Маркер точки входа - показываем если есть фактическая цена входа
                // Приоритет: demo_filled_at (время исполнения) > demo_submitted_at (время отправки) > timestamp (время создания сигнала)
                // Если есть entry_price, значит ордер был исполнен
                const entryTimestamp = signal.demo_filled_at || signal.demo_submitted_at || signal.timestamp;
                const entryPriceForMarker = signal.entry_price; // Фактическая цена исполнения ордера
                
                // Показываем маркер входа если есть фактическая цена входа (entry_price)
                // entry_price устанавливается только после исполнения ордера
                console.log('🔍 Проверка маркера входа для сигнала', signal.id, ':', {
                    entryTimestamp: entryTimestamp,
                    entryPriceForMarker: entryPriceForMarker,
                    demo_filled_at: signal.demo_filled_at,
                    demo_submitted_at: signal.demo_submitted_at,
                    timestamp: signal.timestamp,
                    hasEntryPrice: entryPriceForMarker != null && entryPriceForMarker > 0,
                    hasEntryTimestamp: !!entryTimestamp
                });
                
                // Маркер точки входа - показываем ТОЛЬКО если есть фактическая цена входа И время входа
                // НЕ используем fallback на последнюю свечу - это неправильно!
                if (entryPriceForMarker != null && entryPriceForMarker > 0 && entryTimestamp) {
                    const entryPriceNum = Number(entryPriceForMarker);
                    if (!isNaN(entryPriceNum) && isFinite(entryPriceNum) && entryPriceNum > 0) {
                        try {
                            const entryTime = Math.floor(new Date(entryTimestamp).getTime() / 1000);
                            
                            if (!isNaN(entryTime) && isFinite(entryTime) && entryTime > 0) {
                                // Находим ближайшую свечу к времени входа
                                let entryCandleTime = null;
                                let minDiff = Infinity;
                                
                                if (validatedFinalData && validatedFinalData.length > 0) {
                                    // Ищем свечу, которая содержит время входа или ближайшую к нему
                                    for (const candle of validatedFinalData) {
                                        if (candle && candle.time != null && typeof candle.time === 'number' && !isNaN(candle.time) && isFinite(candle.time)) {
                                            const diff = Math.abs(candle.time - entryTime);
                                            if (diff < minDiff) {
                                                minDiff = diff;
                                                entryCandleTime = candle.time;
                                            }
                                        }
                                    }
                                    
                                    // Если разница слишком большая (> 2 часа), не рисуем маркер
                                    if (minDiff > 7200) {
                                        console.warn(`❌ Время входа слишком далеко от данных графика (${Math.round(minDiff/60)} мин), пропускаем маркер входа`);
                                        entryCandleTime = null;
                                    } else if (minDiff > 3600) {
                                        console.warn(`⚠️ Время входа далеко от данных графика (${Math.round(minDiff/60)} мин), но рисуем маркер`);
                                    }
                                } else {
                                    console.warn('❌ validatedFinalData пуста, не можем найти свечу для маркера входа');
                                    entryCandleTime = null;
                                }

                                if (entryCandleTime != null && typeof entryCandleTime === 'number' && isFinite(entryCandleTime) && entryCandleTime > 0) {
                                    markers.push({
                                        time: entryCandleTime,
                                        position: signal.signal_type === 'LONG' ? 'belowBar' : 'aboveBar',
                                        color: '#4299e1',
                                        shape: signal.signal_type === 'LONG' ? 'arrowUp' : 'arrowDown',
                                        text: `ВХОД ${signal.signal_type} $${entryPriceNum.toFixed(4)}`,
                                        size: 2,
                                    });
                                    console.log(`✅ Маркер входа добавлен: время=${entryCandleTime} (${new Date(entryCandleTime * 1000).toISOString()}), цена=${entryPriceNum}, разница=${Math.round(minDiff)} сек`);
                                } else {
                                    console.warn('❌ Не удалось найти валидную свечу для маркера входа:', { 
                                        entryTime, 
                                        entryCandleTime, 
                                        validatedFinalDataLength: validatedFinalData?.length,
                                        entryTimestamp: entryTimestamp
                                    });
                                }
                            } else {
                                console.warn('❌ Невалидное время входа:', entryTime, 'из timestamp:', entryTimestamp);
                            }
                        } catch (e) {
                            console.warn('❌ Ошибка создания маркера входа:', e);
                        }
                    } else {
                        console.warn('❌ Маркер входа не добавлен - невалидная цена входа:', entryPriceForMarker);
                    }
                } else {
                    console.log('⏭️ Маркер входа не добавлен - нет необходимых данных:', {
                        hasEntryPrice: entryPriceForMarker != null && entryPriceForMarker > 0,
                        hasEntryTimestamp: !!entryTimestamp,
                        entryPriceForMarker: entryPriceForMarker,
                        entryTimestamp: entryTimestamp
                    });
                }

                // Маркер точки выхода - показываем если позиция закрыта
                // Используем exit_timestamp и exit_price (фактическая цена закрытия)
                // Если есть entry_price, значит ордер был исполнен (даже если demo_filled_at не передается)
                const hasExecutedOrder = signal.entry_price && signal.entry_price > 0; // Ордер был исполнен если есть entry_price
                
                if (hasExecutedOrder && signal.exit_timestamp && signal.exit_price != null && signal.exit_price > 0) {
                    const exitPriceNum = Number(signal.exit_price);
                    if (!isNaN(exitPriceNum) && isFinite(exitPriceNum) && exitPriceNum > 0) {
                        try {
                            const exitTime = Math.floor(new Date(signal.exit_timestamp).getTime() / 1000);
                            
                            if (!isNaN(exitTime) && isFinite(exitTime) && exitTime > 0) {
                                // Находим ближайшую свечу к времени выхода
                                let exitCandleTime = exitTime; // Используем время напрямую как fallback
                                let minDiff = Infinity;
                                
                                if (validatedFinalData && validatedFinalData.length > 0) {
                                    for (const candle of validatedFinalData) {
                                        if (candle && candle.time != null && typeof candle.time === 'number' && !isNaN(candle.time) && isFinite(candle.time)) {
                                            const diff = Math.abs(candle.time - exitTime);
                                            if (diff < minDiff) {
                                                minDiff = diff;
                                                exitCandleTime = candle.time;
                                            }
                                        }
                                    }
                                    
                                    // Если разница слишком большая (> 1 час), используем время напрямую
                                    if (minDiff > 3600) {
                                        console.warn(`Время выхода далеко от данных графика (${minDiff} сек), используем время напрямую`);
                                        exitCandleTime = exitTime;
                                    }
                                } else {
                                    console.warn('validatedFinalData пуста, используем время выхода напрямую');
                                    exitCandleTime = exitTime;
                                }

                                if (exitCandleTime != null && typeof exitCandleTime === 'number' && isFinite(exitCandleTime) && exitCandleTime > 0) {
                                    // Рассчитываем фактический результат от реальных цен входа и выхода
                                    const entryPriceForCalc = Number(signal.entry_price);
                                    let actualResultPct = null;
                                    let isTP = false;
                                    
                                    if (entryPriceForCalc && entryPriceForCalc > 0 && exitPriceNum > 0) {
                                        if (signal.signal_type === 'LONG') {
                                            actualResultPct = ((exitPriceNum - entryPriceForCalc) / entryPriceForCalc) * 100.0;
                                        } else { // SHORT
                                            actualResultPct = ((entryPriceForCalc - exitPriceNum) / entryPriceForCalc) * 100.0;
                                        }
                                        isTP = actualResultPct > 0;
                                    }
                                    
                                    // Определяем причину выхода (TP или SL) из exit_reason
                                    const exitReason = signal.exit_reason || '';
                                    const exitLabel = exitReason.includes('TAKE_PROFIT') || exitReason.includes('TP') || (actualResultPct !== null && actualResultPct > 0) ? 'TP' : 'SL';
                                    
                                    // Если не удалось определить из exit_reason, используем фактический результат
                                    const finalIsTP = exitLabel === 'TP' || (actualResultPct !== null && actualResultPct > 0);
                                    
                                    const exitColor = finalIsTP ? '#48bb78' : '#f56565';
                                    const exitShape = signal.signal_type === 'LONG' 
                                        ? (finalIsTP ? 'arrowDown' : 'arrowUp')
                                        : (finalIsTP ? 'arrowUp' : 'arrowDown');
                                    
                                    // Форматируем текст с фактическим результатом
                                    const resultText = actualResultPct !== null 
                                        ? `${actualResultPct >= 0 ? '+' : ''}${actualResultPct.toFixed(2)}%`
                                        : (signal.result_fixed ? `${signal.result_fixed >= 0 ? '+' : ''}${signal.result_fixed}%` : '');

                                    markers.push({
                                        time: exitCandleTime,
                                        position: signal.signal_type === 'LONG' 
                                            ? (finalIsTP ? 'aboveBar' : 'belowBar')
                                            : (finalIsTP ? 'belowBar' : 'aboveBar'),
                                        color: exitColor,
                                        shape: exitShape,
                                        text: `ВЫХОД ${exitLabel} ${resultText} $${exitPriceNum.toFixed(4)}`,
                                        size: 2,
                                    });
                                    console.log(`✅ Маркер выхода добавлен: время=${exitCandleTime} (${new Date(exitCandleTime * 1000).toISOString()}), цена=${exitPriceNum}, фактический результат=${actualResultPct !== null ? actualResultPct.toFixed(2) + '%' : 'N/A'}, причина=${exitLabel}`);
                                } else {
                                    console.warn('Не удалось найти валидное время для маркера выхода:', { exitTime, exitCandleTime, validatedFinalDataLength: validatedFinalData?.length });
                                }
                            } else {
                                console.warn('Невалидное время выхода:', exitTime, 'из timestamp:', signal.exit_timestamp);
                            }
                        } catch (e) {
                            console.warn('Ошибка создания маркера выхода:', e);
                        }
                    } else {
                        console.warn('Маркер выхода не добавлен - невалидная цена выхода:', signal.exit_price);
                    }
                } else {
                    console.log('Маркер выхода не добавлен - условия не выполнены:', {
                        hasExecutedOrder: hasExecutedOrder,
                        entry_price: signal.entry_price,
                        exit_timestamp: !!signal.exit_timestamp,
                        exit_price: signal.exit_price
                    });
                }

                // Добавляем маркеры только если они валидны
                console.log(`📊 Всего создано маркеров: ${markers.length}`, markers);
                try {
                    if (markers.length > 0) {
                        // Дополнительная проверка маркеров
                        const validMarkers = markers.filter(marker => {
                            const isValid = marker != null &&
                                   marker.time != null && 
                                   typeof marker.time === 'number' && 
                                   !isNaN(marker.time) &&
                                   isFinite(marker.time) &&
                                   marker.time > 0 &&
                                   marker.color != null &&
                                   marker.shape != null &&
                                   marker.position != null;
                            if (!isValid) {
                                console.warn('Невалидный маркер отфильтрован:', marker);
                            }
                            return isValid;
                        });
                        
                        console.log(`📊 Валидных маркеров: ${validMarkers.length} из ${markers.length}`);
                        
                        if (validMarkers.length > 0) {
                            candlestickSeries.setMarkers(validMarkers);
                            console.log(`✅ Добавлено ${validMarkers.length} маркеров на график:`, validMarkers);
                        } else {
                            console.warn('Нет валидных маркеров для добавления. Все маркеры:', markers);
                        }
                    } else {
                        console.warn('Нет маркеров для добавления. Проверка условий:', {
                            entryTimestamp: signal.demo_filled_at,
                            entryPrice: signal.entry_price,
                            exitTimestamp: signal.exit_timestamp,
                            exitPrice: signal.exit_price,
                            status: signal.status
                        });
                    }
                } catch (e) {
                    console.error('Ошибка добавления маркеров:', e);
                }

                // Добавляем линии для точек входа и выхода
                // ВАЖНО: LightweightCharts очень чувствителен к null/undefined значениям
                // Поэтому проверяем ВСЕ значения перед созданием линий
                
                // Линия входа
                // Используем validatedFinalData вместо finalData
                if (signal.entry_price != null && validatedFinalData && validatedFinalData.length > 0) {
                    try {
                        const entryPriceNum = parseFloat(signal.entry_price);
                        
                        // Строгая валидация цены входа
                        if (isNaN(entryPriceNum) || !isFinite(entryPriceNum) || entryPriceNum <= 0) {
                            console.warn('Цена входа невалидна:', signal.entry_price, entryPriceNum);
                        } else {
                            const firstCandle = validatedFinalData[0];
                            const lastCandle = validatedFinalData[validatedFinalData.length - 1];
                            
                            // Валидация времени свечей (используем Number вместо parseInt)
                            const firstTime = firstCandle && firstCandle.time != null 
                                ? Number(firstCandle.time) 
                                : null;
                            const lastTime = lastCandle && lastCandle.time != null 
                                ? Number(lastCandle.time) 
                                : null;
                            
                            // Проверяем, что времена валидны
                            if (firstTime != null && lastTime != null && 
                                typeof firstTime === 'number' &&
                                typeof lastTime === 'number' &&
                                !isNaN(firstTime) && !isNaN(lastTime) &&
                                isFinite(firstTime) && isFinite(lastTime) &&
                                firstTime > 0 && lastTime > 0 &&
                                firstTime <= lastTime &&
                                typeof entryPriceNum === 'number' &&
                                !isNaN(entryPriceNum) && isFinite(entryPriceNum) &&
                                entryPriceNum > 0) {
                                
                                // Создаем данные линии с гарантированно валидными значениями
                                // Убеждаемся, что все значения являются целыми числами для time
                                const lineData = [
                                    { time: Math.floor(firstTime), value: Number(entryPriceNum) },
                                    { time: Math.floor(lastTime), value: Number(entryPriceNum) }
                                ];
                                
                                // Финальная проверка каждого значения перед передачей в библиотеку
                                const allValid = lineData.every((point, idx) => {
                                    const valid = point != null &&
                                                 point.time != null && 
                                                 point.value != null &&
                                                 typeof point.time === 'number' &&
                                                 typeof point.value === 'number' &&
                                                 !isNaN(point.time) && !isNaN(point.value) &&
                                                 isFinite(point.time) && isFinite(point.value) &&
                                                 point.time > 0 && point.value > 0;
                                    if (!valid) {
                                        console.error(`❌ Невалидная точка #${idx} линии входа:`, point, {
                                            timeType: typeof point.time,
                                            valueType: typeof point.value,
                                            timeIsNaN: isNaN(point.time),
                                            valueIsNaN: isNaN(point.value)
                                        });
                                    }
                                    return valid;
                                });
                                
                                if (allValid && lineData.length === 2) {
                                    try {
                                        // Удаляем старую линию входа, если она существует
                                        if (currentEntryLineSeries) {
                                            try {
                                                currentSignalChart.removeSeries(currentEntryLineSeries);
                                            } catch (e) {
                                                console.warn('Ошибка при удалении старой линии входа:', e);
                                            }
                                            currentEntryLineSeries = null;
                                        }
                                        
                                        const entryLineSeries = currentSignalChart.addLineSeries({
                                            color: '#4299e1',
                                            lineWidth: 2,
                                            lineStyle: LightweightCharts.LineStyle.Dashed,
                                            title: 'Точка входа',
                                        });
                                        
                                        entryLineSeries.setData(lineData);
                                        currentEntryLineSeries = entryLineSeries; // Сохраняем ссылку
                                        console.log('✅ Линия входа добавлена:', lineData);
                                    } catch (e) {
                                        console.error('❌ Ошибка при создании/установке линии входа:', e, e.stack);
                                        console.error('Данные линии:', lineData);
                                    }
                                } else {
                                    console.error('❌ Данные линии входа содержат невалидные значения или неполные', {
                                        allValid,
                                        length: lineData.length,
                                        lineData
                                    });
                                }
                            } else {
                                console.warn('Время свечей или цена входа невалидна для линии входа:', { 
                                    firstTime, 
                                    lastTime, 
                                    entryPriceNum,
                                    firstTimeType: typeof firstTime,
                                    lastTimeType: typeof lastTime,
                                    entryPriceNumType: typeof entryPriceNum
                                });
                            }
                        }
                    } catch (e) {
                        console.error('Ошибка создания линии входа:', e, e.stack);
                    }
                }

                // Линия выхода
                if (signal.exit_price != null && signal.exit_timestamp && validatedFinalData && validatedFinalData.length > 0) {
                    try {
                        const exitPriceNum = parseFloat(signal.exit_price);
                        
                        // Строгая валидация цены выхода
                        if (isNaN(exitPriceNum) || !isFinite(exitPriceNum) || exitPriceNum <= 0) {
                            console.warn('Цена выхода невалидна:', signal.exit_price, exitPriceNum);
                        } else {
                            // Конвертируем время выхода
                            let exitTime = null;
                            try {
                                const exitDate = new Date(signal.exit_timestamp);
                                if (!isNaN(exitDate.getTime())) {
                                    exitTime = Math.floor(exitDate.getTime() / 1000);
                                }
                            } catch (e) {
                                console.warn('Ошибка парсинга времени выхода:', e);
                            }
                            
                            if (exitTime != null && !isNaN(exitTime) && isFinite(exitTime) && exitTime > 0) {
                                const lastCandle = validatedFinalData[validatedFinalData.length - 1];
                                const lastTime = lastCandle && lastCandle.time != null 
                                    ? Number(lastCandle.time) 
                                    : null;
                                
                                // Проверяем, что время последней свечи валидно
                                if (lastTime != null && 
                                    typeof lastTime === 'number' &&
                                    !isNaN(lastTime) && isFinite(lastTime) && lastTime > 0 &&
                                    typeof exitTime === 'number' &&
                                    !isNaN(exitTime) && isFinite(exitTime) && exitTime > 0 &&
                                    exitTime <= lastTime &&
                                    typeof exitPriceNum === 'number' &&
                                    !isNaN(exitPriceNum) && isFinite(exitPriceNum) &&
                                    exitPriceNum > 0) {
                                    
                                    // Создаем данные линии с гарантированно валидными значениями
                                    // Убеждаемся, что все значения являются числами
                                    const lineData = [
                                        { time: Math.floor(exitTime), value: Number(exitPriceNum) },
                                        { time: Math.floor(lastTime), value: Number(exitPriceNum) }
                                    ];
                                    
                                    // Дополнительная проверка каждого значения
                                    const allValid = lineData.every((point, idx) => {
                                        const valid = point != null &&
                                                     point.time != null && 
                                                     point.value != null &&
                                                     typeof point.time === 'number' &&
                                                     typeof point.value === 'number' &&
                                                     !isNaN(point.time) && !isNaN(point.value) &&
                                                     isFinite(point.time) && isFinite(point.value) &&
                                                     point.time > 0 && point.value > 0;
                                        if (!valid) {
                                            console.error(`❌ Невалидная точка #${idx} линии выхода:`, point, {
                                                timeType: typeof point.time,
                                                valueType: typeof point.value,
                                                timeIsNaN: isNaN(point.time),
                                                valueIsNaN: isNaN(point.value)
                                            });
                                        }
                                        return valid;
                                    });
                                    
                                    if (allValid && lineData.length === 2) {
                                        const resultFixedNum = signal.result_fixed != null 
                                            ? Number(signal.result_fixed) 
                                            : null;
                                        
                                        if (resultFixedNum != null && !isNaN(resultFixedNum) && isFinite(resultFixedNum)) {
                                            try {
                                                // Удаляем старую линию выхода, если она существует
                                                if (currentExitLineSeries) {
                                                    try {
                                                        currentSignalChart.removeSeries(currentExitLineSeries);
                                                    } catch (e) {
                                                        console.warn('Ошибка при удалении старой линии выхода:', e);
                                                    }
                                                    currentExitLineSeries = null;
                                                }
                                                
                                                const exitLineSeries = currentSignalChart.addLineSeries({
                                                    color: resultFixedNum === 1.5 ? '#48bb78' : '#f56565',
                                                    lineWidth: 2,
                                                    lineStyle: LightweightCharts.LineStyle.Dashed,
                                                    title: 'Точка выхода',
                                                });
                                                
                                                exitLineSeries.setData(lineData);
                                                currentExitLineSeries = exitLineSeries; // Сохраняем ссылку
                                                console.log('✅ Линия выхода добавлена:', lineData);
                                            } catch (e) {
                                                console.error('❌ Ошибка при создании/установке линии выхода:', e, e.stack);
                                                console.error('Данные линии:', lineData);
                                            }
                                        } else {
                                            console.warn('result_fixed невалиден:', signal.result_fixed);
                                        }
                                    } else {
                                        console.error('❌ Данные линии выхода содержат невалидные значения или неполные', {
                                            allValid,
                                            length: lineData.length,
                                            lineData
                                        });
                                    }
                                } else {
                                    console.warn('Время последней свечи или цена выхода невалидна:', { 
                                        exitTime, 
                                        lastTime, 
                                        exitPriceNum,
                                        exitTimeType: typeof exitTime,
                                        lastTimeType: typeof lastTime,
                                        exitPriceNumType: typeof exitPriceNum
                                    });
                                }
                            } else {
                                console.warn('Время выхода невалидно:', exitTime);
                            }
                        }
                    } catch (e) {
                        console.error('Ошибка создания линии выхода:', e, e.stack);
                    }
                }

                // Показываем всю доступную историю, чтобы сразу видеть общую картину
                if (validatedFinalData && validatedFinalData.length > 0) {
                    try {
                        // fitContent автоматически выставляет масштаб по всей выборке свечей
                        currentSignalChart.timeScale().fitContent();

                        // Если данных мало (менее 48 свечей), добавляем запас по времени,
                        // чтобы график не выглядел чрезмерно приближенным
                        if (validatedFinalData.length < 48) {
                            const firstTime = validatedFinalData[0].time;
                            const lastTime = validatedFinalData[validatedFinalData.length - 1].time;
                            if (typeof firstTime === 'number' && typeof lastTime === 'number' &&
                                isFinite(firstTime) && isFinite(lastTime) &&
                                lastTime > firstTime) {
                                const minSpanSeconds = 48 * 15 * 60; // 48 свечей по 15 минут
                                const currentSpan = lastTime - firstTime;
                                if (currentSpan < minSpanSeconds) {
                                    const extra = (minSpanSeconds - currentSpan) / 2;
                                    currentSignalChart.timeScale().setVisibleRange({
                                        from: Math.max(0, firstTime - extra),
                                        to: lastTime + extra,
                                    });
                                    console.log(`✅ Видимый диапазон расширен до минимум 48 свечей`);
                                }
                            }
                        }
                    } catch (e) {
                        console.warn('Ошибка автоматической установки масштаба графика:', e);
                    }
                } else {
                    console.warn('validatedFinalData пуста или отсутствует');
                }

                // Обработка изменения размера
                const resizeObserver = new ResizeObserver(entries => {
                    if (entries.length === 0 || entries[0].target !== container) return;
                    if (!currentSignalChart) {
                        // Сохраняем ссылку на observer перед отключением
                        const observer = signalChartResizeObserver;
                        if (observer) {
                            try {
                                observer.disconnect();
                            } catch (e) {
                                console.warn('Ошибка при отключении ResizeObserver:', e);
                            }
                        }
                        signalChartResizeObserver = null;
                        return;
                    }
                    try {
                        const newRect = entries[0].contentRect;
                        currentSignalChart.applyOptions({ width: newRect.width, height: newRect.height });
                    } catch (error) {
                        console.warn('Ошибка при изменении размера графика:', error);
                        // Сохраняем ссылку на observer перед отключением
                        const observer = signalChartResizeObserver;
                        if (observer) {
                            try {
                                observer.disconnect();
                            } catch (e) {
                                console.warn('Ошибка при отключении ResizeObserver:', e);
                            }
                        }
                        signalChartResizeObserver = null;
                    }
                });
                signalChartResizeObserver = resizeObserver;
                signalChartResizeObserver.observe(container);

            } catch (error) {
                console.error('Ошибка создания графика:', error);
                container.innerHTML = `<div style="color: #f56565; padding: 2rem; text-align: center;">Ошибка создания графика: ${error.message}</div>`;
            }
        }

        // Смена таймфрейма
        async function changeSignalTimeframe() {
            if (!currentSignalId) return;

            // Отключаем старый ResizeObserver
            if (signalChartResizeObserver) {
                signalChartResizeObserver.disconnect();
                signalChartResizeObserver = null;
            }

            // Удаляем старый график
            if (currentSignalChart) {
                try {
                    currentSignalChart.remove();
                } catch (e) {
                    console.warn('Ошибка при удалении графика:', e);
                }
                currentSignalChart = null;
            }

            // Показываем индикатор загрузки
            document.getElementById('signal-chart-container').innerHTML = `
                <div style="display: flex; align-items: center; justify-content: center; height: 100%; color: #a0aec0;">
                    <div style="text-align: center;">
                        <div class="spinner"></div>
                        <p style="margin-top: 1rem;">Загрузка данных...</p>
                    </div>
                </div>
            `;

            // Загружаем данные с новым таймфреймом
            await loadSignalChartData(currentSignalId, document.getElementById('signal-timeframe-selector').value);
        }

        // Закрытие модального окна при клике вне его
        document.addEventListener('click', function(event) {
            const modal = document.getElementById('signal-chart-modal');
            if (event.target === modal) {
                closeSignalChart();
            }
        });

        // Закрытие модального окна при нажатии Escape
        document.addEventListener('keydown', function(event) {
            if (event.key === 'Escape') {
                const modal = document.getElementById('signal-chart-modal');
                if (modal.classList.contains('active')) {
                    closeSignalChart();
                }
            }
        });
    </script>
</body>
</html> 